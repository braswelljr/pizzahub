var Vue=function(exports){"use strict";function makeMap(str,expectsLowerCase){const map=Object.create(null),list=str.split(",");for(let i=0;i<list.length;i++)map[list[i]]=!0;return expectsLowerCase?val=>!!map[val.toLowerCase()]:val=>!!map[val]}const PatchFlagNames={1:"TEXT",2:"CLASS",4:"STYLE",8:"PROPS",16:"FULL_PROPS",32:"HYDRATE_EVENTS",64:"STABLE_FRAGMENT",128:"KEYED_FRAGMENT",256:"UNKEYED_FRAGMENT",1024:"DYNAMIC_SLOTS",512:"NEED_PATCH",[-1]:"HOISTED",[-2]:"BAIL"},GLOBALS_WHITE_LISTED="Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl",isGloballyWhitelisted=makeMap(GLOBALS_WHITE_LISTED),range=2;function generateCodeFrame(source,start=0,end=source.length){const lines=source.split(/\r?\n/);let count=0;const res=[];for(let i=0;i<lines.length;i++)if(count+=lines[i].length+1,count>=start){for(let j=i-2;j<=i+2||end>count;j++){if(j<0||j>=lines.length)continue;const line=j+1;res.push(`${line}${" ".repeat(Math.max(3-String(line).length,0))}|  ${lines[j]}`);const lineLength=lines[j].length;if(j===i){const pad=start-(count-lineLength)+1,length=Math.max(1,end>count?lineLength-pad:end-start);res.push("   |  "+" ".repeat(pad)+"^".repeat(length))}else if(j>i){if(end>count){const length=Math.max(Math.min(end-count,lineLength),1);res.push("   |  "+"^".repeat(length))}count+=lineLength+1}}break}return res.join("\n")}const specialBooleanAttrs="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",isSpecialBooleanAttr=makeMap(specialBooleanAttrs);function normalizeStyle(value){if(isArray(value)){const res={};for(let i=0;i<value.length;i++){const item=value[i],normalized=normalizeStyle(isString(item)?parseStringStyle(item):item);if(normalized)for(const key in normalized)res[key]=normalized[key]}return res}if(isObject(value))return value}const listDelimiterRE=/;(?![^(]*\))/g,propertyDelimiterRE=/:(.+)/;function parseStringStyle(cssText){const ret={};return cssText.split(listDelimiterRE).forEach(item=>{if(item){const tmp=item.split(propertyDelimiterRE);tmp.length>1&&(ret[tmp[0].trim()]=tmp[1].trim())}}),ret}function normalizeClass(value){let res="";if(isString(value))res=value;else if(isArray(value))for(let i=0;i<value.length;i++)res+=normalizeClass(value[i])+" ";else if(isObject(value))for(const name in value)value[name]&&(res+=name+" ");return res.trim()}const HTML_TAGS="html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",SVG_TAGS="svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",VOID_TAGS="area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr",isHTMLTag=makeMap(HTML_TAGS),isSVGTag=makeMap(SVG_TAGS),isVoidTag=makeMap(VOID_TAGS);function looseCompareArrays(a,b){if(a.length!==b.length)return!1;let equal=!0;for(let i=0;equal&&i<a.length;i++)equal=looseEqual(a[i],b[i]);return equal}function looseEqual(a,b){if(a===b)return!0;let aValidType=isDate(a),bValidType=isDate(b);if(aValidType||bValidType)return!(!aValidType||!bValidType)&&a.getTime()===b.getTime();if(aValidType=isArray(a),bValidType=isArray(b),aValidType||bValidType)return!(!aValidType||!bValidType)&&looseCompareArrays(a,b);if(aValidType=isObject(a),bValidType=isObject(b),aValidType||bValidType){if(!aValidType||!bValidType)return!1;const aKeysCount=Object.keys(a).length,bKeysCount=Object.keys(b).length;if(aKeysCount!==bKeysCount)return!1;for(const key in a){const aHasKey=a.hasOwnProperty(key),bHasKey=b.hasOwnProperty(key);if(aHasKey&&!bHasKey||!aHasKey&&bHasKey||!looseEqual(a[key],b[key]))return!1}}return String(a)===String(b)}function looseIndexOf(arr,val){return arr.findIndex(item=>looseEqual(item,val))}function looseHas(set,val){for(let item of set)if(looseEqual(item,val))return!0;return!1}const toDisplayString=val=>null==val?"":isObject(val)?JSON.stringify(val,replacer,2):String(val),replacer=(_key,val)=>isMap(val)?{[`Map(${val.size})`]:[...val.entries()].reduce((entries,[key,val])=>(entries[`${key} =>`]=val,entries),{})}:isSet(val)?{[`Set(${val.size})`]:[...val.values()]}:!isObject(val)||isArray(val)||isPlainObject(val)?val:String(val),EMPTY_OBJ=Object.freeze({}),EMPTY_ARR=[],NOOP=()=>{},NO=()=>!1,onRE=/^on[^a-z]/,isOn=key=>onRE.test(key),isModelListener=key=>key.startsWith("onUpdate:"),extend=Object.assign,remove=(arr,el)=>{const i=arr.indexOf(el);i>-1&&arr.splice(i,1)},hasOwnProperty=Object.prototype.hasOwnProperty,hasOwn=(val,key)=>hasOwnProperty.call(val,key),isArray=Array.isArray,isMap=val=>"[object Map]"===toTypeString(val),isSet=val=>"[object Set]"===toTypeString(val),isDate=val=>val instanceof Date,isFunction=val=>"function"==typeof val,isString=val=>"string"==typeof val,isSymbol=val=>"symbol"==typeof val,isObject=val=>null!==val&&"object"==typeof val,isPromise=val=>isObject(val)&&isFunction(val.then)&&isFunction(val.catch),objectToString=Object.prototype.toString,toTypeString=value=>objectToString.call(value),toRawType=value=>toTypeString(value).slice(8,-1),isPlainObject=val=>"[object Object]"===toTypeString(val),isIntegerKey=key=>isString(key)&&"NaN"!==key&&"-"!==key[0]&&""+parseInt(key,10)===key,isReservedProp=makeMap("key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),cacheStringFunction=fn=>{const cache=Object.create(null);return str=>{const hit=cache[str];return hit||(cache[str]=fn(str))}},camelizeRE=/-(\w)/g,camelize=cacheStringFunction(str=>str.replace(camelizeRE,(_,c)=>c?c.toUpperCase():"")),hyphenateRE=/\B([A-Z])/g,hyphenate=cacheStringFunction(str=>str.replace(hyphenateRE,"-$1").toLowerCase()),capitalize=cacheStringFunction(str=>str.charAt(0).toUpperCase()+str.slice(1)),hasChanged=(value,oldValue)=>value!==oldValue&&(value==value||oldValue==oldValue),invokeArrayFns=(fns,arg)=>{for(let i=0;i<fns.length;i++)fns[i](arg)},def=(obj,key,value)=>{Object.defineProperty(obj,key,{configurable:!0,enumerable:!1,value:value})},toNumber=val=>{const n=parseFloat(val);return isNaN(n)?val:n};let _globalThis;const getGlobalThis=()=>_globalThis||(_globalThis="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{}),targetMap=new WeakMap,effectStack=[];let activeEffect;const ITERATE_KEY=Symbol("iterate"),MAP_KEY_ITERATE_KEY=Symbol("Map key iterate");function isEffect(fn){return fn&&!0===fn._isEffect}function effect(fn,options=EMPTY_OBJ){isEffect(fn)&&(fn=fn.raw);const effect=createReactiveEffect(fn,options);return options.lazy||effect(),effect}function stop(effect){effect.active&&(cleanup(effect),effect.options.onStop&&effect.options.onStop(),effect.active=!1)}let uid=0;function createReactiveEffect(fn,options){const effect=function reactiveEffect(){if(!effect.active)return options.scheduler?void 0:fn();if(!effectStack.includes(effect)){cleanup(effect);try{return enableTracking(),effectStack.push(effect),activeEffect=effect,fn()}finally{effectStack.pop(),resetTracking(),activeEffect=effectStack[effectStack.length-1]}}};return effect.id=uid++,effect._isEffect=!0,effect.active=!0,effect.raw=fn,effect.deps=[],effect.options=options,effect}function cleanup(effect){const{deps:deps}=effect;if(deps.length){for(let i=0;i<deps.length;i++)deps[i].delete(effect);deps.length=0}}let shouldTrack=!0;const trackStack=[];function pauseTracking(){trackStack.push(shouldTrack),shouldTrack=!1}function enableTracking(){trackStack.push(shouldTrack),shouldTrack=!0}function resetTracking(){const last=trackStack.pop();shouldTrack=void 0===last||last}function track(target,type,key){if(!shouldTrack||void 0===activeEffect)return;let depsMap=targetMap.get(target);depsMap||targetMap.set(target,depsMap=new Map);let dep=depsMap.get(key);dep||depsMap.set(key,dep=new Set),dep.has(activeEffect)||(dep.add(activeEffect),activeEffect.deps.push(dep),activeEffect.options.onTrack&&activeEffect.options.onTrack({effect:activeEffect,target:target,type:type,key:key}))}function trigger(target,type,key,newValue,oldValue,oldTarget){const depsMap=targetMap.get(target);if(!depsMap)return;const effects=new Set,add=effectsToAdd=>{effectsToAdd&&effectsToAdd.forEach(effect=>{(effect!==activeEffect||effect.options.allowRecurse)&&effects.add(effect)})};if("clear"===type)depsMap.forEach(add);else if("length"===key&&isArray(target))depsMap.forEach((dep,key)=>{("length"===key||key>=newValue)&&add(dep)});else switch(void 0!==key&&add(depsMap.get(key)),type){case"add":isArray(target)?isIntegerKey(key)&&add(depsMap.get("length")):(add(depsMap.get(ITERATE_KEY)),isMap(target)&&add(depsMap.get(MAP_KEY_ITERATE_KEY)));break;case"delete":isArray(target)||(add(depsMap.get(ITERATE_KEY)),isMap(target)&&add(depsMap.get(MAP_KEY_ITERATE_KEY)));break;case"set":isMap(target)&&add(depsMap.get(ITERATE_KEY))}const run=effect=>{effect.options.onTrigger&&effect.options.onTrigger({effect:effect,target:target,key:key,type:type,newValue:newValue,oldValue:oldValue,oldTarget:oldTarget}),effect.options.scheduler?effect.options.scheduler(effect):effect()};effects.forEach(run)}const builtInSymbols=new Set(Object.getOwnPropertyNames(Symbol).map(key=>Symbol[key]).filter(isSymbol)),get=createGetter(),shallowGet=createGetter(!1,!0),readonlyGet=createGetter(!0),shallowReadonlyGet=createGetter(!0,!0),arrayInstrumentations={};function createGetter(isReadonly=!1,shallow=!1){return function get(target,key,receiver){if("__v_isReactive"===key)return!isReadonly;if("__v_isReadonly"===key)return isReadonly;if("__v_raw"===key&&receiver===(isReadonly?readonlyMap:reactiveMap).get(target))return target;const targetIsArray=isArray(target);if(targetIsArray&&hasOwn(arrayInstrumentations,key))return Reflect.get(arrayInstrumentations,key,receiver);const res=Reflect.get(target,key,receiver),keyIsSymbol=isSymbol(key);if(keyIsSymbol?builtInSymbols.has(key):"__proto__"===key||"__v_isRef"===key)return res;if(isReadonly||track(target,"get",key),shallow)return res;if(isRef(res)){const shouldUnwrap=!targetIsArray||!isIntegerKey(key);return shouldUnwrap?res.value:res}return isObject(res)?isReadonly?readonly(res):reactive(res):res}}["includes","indexOf","lastIndexOf"].forEach(key=>{const method=Array.prototype[key];arrayInstrumentations[key]=function(...args){const arr=toRaw(this);for(let i=0,l=this.length;i<l;i++)track(arr,"get",i+"");const res=method.apply(arr,args);return-1===res||!1===res?method.apply(arr,args.map(toRaw)):res}}),["push","pop","shift","unshift","splice"].forEach(key=>{const method=Array.prototype[key];arrayInstrumentations[key]=function(...args){pauseTracking();const res=method.apply(this,args);return enableTracking(),res}});const set=createSetter(),shallowSet=createSetter(!0);function createSetter(shallow=!1){return function set(target,key,value,receiver){const oldValue=target[key];if(!shallow&&(value=toRaw(value),!isArray(target)&&isRef(oldValue)&&!isRef(value)))return oldValue.value=value,!0;const hadKey=isArray(target)&&isIntegerKey(key)?Number(key)<target.length:hasOwn(target,key),result=Reflect.set(target,key,value,receiver);return target===toRaw(receiver)&&(hadKey?hasChanged(value,oldValue)&&trigger(target,"set",key,value,oldValue):trigger(target,"add",key,value)),result}}function deleteProperty(target,key){const hadKey=hasOwn(target,key),oldValue=target[key],result=Reflect.deleteProperty(target,key);return result&&hadKey&&trigger(target,"delete",key,void 0,oldValue),result}function has(target,key){const result=Reflect.has(target,key);return isSymbol(key)&&builtInSymbols.has(key)||track(target,"has",key),result}function ownKeys(target){return track(target,"iterate",ITERATE_KEY),Reflect.ownKeys(target)}const mutableHandlers={get:get,set:set,deleteProperty:deleteProperty,has:has,ownKeys:ownKeys},readonlyHandlers={get:readonlyGet,set:(target,key)=>(console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`,target),!0),deleteProperty:(target,key)=>(console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`,target),!0)},shallowReactiveHandlers=extend({},mutableHandlers,{get:shallowGet,set:shallowSet}),shallowReadonlyHandlers=extend({},readonlyHandlers,{get:shallowReadonlyGet}),toReactive=value=>isObject(value)?reactive(value):value,toReadonly=value=>isObject(value)?readonly(value):value,toShallow=value=>value,getProto=v=>Reflect.getPrototypeOf(v);function get$1(target,key,isReadonly=!1,isShallow=!1){const rawTarget=toRaw(target=target.__v_raw),rawKey=toRaw(key);key!==rawKey&&!isReadonly&&track(rawTarget,"get",key),!isReadonly&&track(rawTarget,"get",rawKey);const{has:has}=getProto(rawTarget),wrap=isReadonly?toReadonly:isShallow?toShallow:toReactive;return has.call(rawTarget,key)?wrap(target.get(key)):has.call(rawTarget,rawKey)?wrap(target.get(rawKey)):void 0}function has$1(key,isReadonly=!1){const target=this.__v_raw,rawTarget=toRaw(target),rawKey=toRaw(key);return key!==rawKey&&!isReadonly&&track(rawTarget,"has",key),!isReadonly&&track(rawTarget,"has",rawKey),key===rawKey?target.has(key):target.has(key)||target.has(rawKey)}function size(target,isReadonly=!1){return target=target.__v_raw,!isReadonly&&track(toRaw(target),"iterate",ITERATE_KEY),Reflect.get(target,"size",target)}function add(value){value=toRaw(value);const target=toRaw(this),proto=getProto(target),hadKey=proto.has.call(target,value),result=target.add(value);return hadKey||trigger(target,"add",value,value),result}function set$1(key,value){value=toRaw(value);const target=toRaw(this),{has:has,get:get}=getProto(target);let hadKey=has.call(target,key);hadKey?checkIdentityKeys(target,has,key):(key=toRaw(key),hadKey=has.call(target,key));const oldValue=get.call(target,key),result=target.set(key,value);return hadKey?hasChanged(value,oldValue)&&trigger(target,"set",key,value,oldValue):trigger(target,"add",key,value),result}function deleteEntry(key){const target=toRaw(this),{has:has,get:get}=getProto(target);let hadKey=has.call(target,key);hadKey?checkIdentityKeys(target,has,key):(key=toRaw(key),hadKey=has.call(target,key));const oldValue=get?get.call(target,key):void 0,result=target.delete(key);return hadKey&&trigger(target,"delete",key,void 0,oldValue),result}function clear(){const target=toRaw(this),hadItems=0!==target.size,oldTarget=isMap(target)?new Map(target):new Set(target),result=target.clear();return hadItems&&trigger(target,"clear",void 0,void 0,oldTarget),result}function createForEach(isReadonly,isShallow){return function forEach(callback,thisArg){const observed=this,target=observed.__v_raw,rawTarget=toRaw(target),wrap=isReadonly?toReadonly:isShallow?toShallow:toReactive;return!isReadonly&&track(rawTarget,"iterate",ITERATE_KEY),target.forEach((value,key)=>callback.call(thisArg,wrap(value),wrap(key),observed))}}function createIterableMethod(method,isReadonly,isShallow){return function(...args){const target=this.__v_raw,rawTarget=toRaw(target),targetIsMap=isMap(rawTarget),isPair="entries"===method||method===Symbol.iterator&&targetIsMap,isKeyOnly="keys"===method&&targetIsMap,innerIterator=target[method](...args),wrap=isReadonly?toReadonly:isShallow?toShallow:toReactive;return!isReadonly&&track(rawTarget,"iterate",isKeyOnly?MAP_KEY_ITERATE_KEY:ITERATE_KEY),{next(){const{value:value,done:done}=innerIterator.next();return done?{value:value,done:done}:{value:isPair?[wrap(value[0]),wrap(value[1])]:wrap(value),done:done}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(type){return function(...args){{const key=args[0]?`on key "${args[0]}" `:"";console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`,toRaw(this))}return"delete"!==type&&this}}const mutableInstrumentations={get(key){return get$1(this,key)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(!1,!1)},shallowInstrumentations={get(key){return get$1(this,key,!1,!0)},get size(){return size(this)},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(!1,!0)},readonlyInstrumentations={get(key){return get$1(this,key,!0)},get size(){return size(this,!0)},has(key){return has$1.call(this,key,!0)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(!0,!1)},iteratorMethods=["keys","values","entries",Symbol.iterator];function createInstrumentationGetter(isReadonly,shallow){const instrumentations=shallow?shallowInstrumentations:isReadonly?readonlyInstrumentations:mutableInstrumentations;return(target,key,receiver)=>"__v_isReactive"===key?!isReadonly:"__v_isReadonly"===key?isReadonly:"__v_raw"===key?target:Reflect.get(hasOwn(instrumentations,key)&&key in target?instrumentations:target,key,receiver)}iteratorMethods.forEach(method=>{mutableInstrumentations[method]=createIterableMethod(method,!1,!1),readonlyInstrumentations[method]=createIterableMethod(method,!0,!1),shallowInstrumentations[method]=createIterableMethod(method,!1,!0)});const mutableCollectionHandlers={get:createInstrumentationGetter(!1,!1)},shallowCollectionHandlers={get:createInstrumentationGetter(!1,!0)},readonlyCollectionHandlers={get:createInstrumentationGetter(!0,!1)};function checkIdentityKeys(target,has,key){const rawKey=toRaw(key);if(rawKey!==key&&has.call(target,rawKey)){const type=toRawType(target);console.warn(`Reactive ${type} contains both the raw and reactive `+`versions of the same object${"Map"===type?"as keys":""}, `+"which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.")}}const reactiveMap=new WeakMap,readonlyMap=new WeakMap;function targetTypeMap(rawType){switch(rawType){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function getTargetType(value){return value.__v_skip||!Object.isExtensible(value)?0:targetTypeMap(toRawType(value))}function reactive(target){return target&&target.__v_isReadonly?target:createReactiveObject(target,!1,mutableHandlers,mutableCollectionHandlers)}function shallowReactive(target){return createReactiveObject(target,!1,shallowReactiveHandlers,shallowCollectionHandlers)}function readonly(target){return createReactiveObject(target,!0,readonlyHandlers,readonlyCollectionHandlers)}function shallowReadonly(target){return createReactiveObject(target,!0,shallowReadonlyHandlers,readonlyCollectionHandlers)}function createReactiveObject(target,isReadonly,baseHandlers,collectionHandlers){if(!isObject(target))return console.warn(`value cannot be made reactive: ${String(target)}`),target;if(target.__v_raw&&(!isReadonly||!target.__v_isReactive))return target;const proxyMap=isReadonly?readonlyMap:reactiveMap,existingProxy=proxyMap.get(target);if(existingProxy)return existingProxy;const targetType=getTargetType(target);if(0===targetType)return target;const proxy=new Proxy(target,2===targetType?collectionHandlers:baseHandlers);return proxyMap.set(target,proxy),proxy}function isReactive(value){return isReadonly(value)?isReactive(value.__v_raw):!(!value||!value.__v_isReactive)}function isReadonly(value){return!(!value||!value.__v_isReadonly)}function isProxy(value){return isReactive(value)||isReadonly(value)}function toRaw(observed){return observed&&toRaw(observed.__v_raw)||observed}function markRaw(value){return def(value,"__v_skip",!0),value}const convert=val=>isObject(val)?reactive(val):val;function isRef(r){return Boolean(r&&!0===r.__v_isRef)}function ref(value){return createRef(value)}function shallowRef(value){return createRef(value,!0)}class RefImpl{constructor(_rawValue,_shallow=!1){this._rawValue=_rawValue,this._shallow=_shallow,this.__v_isRef=!0,this._value=_shallow?_rawValue:convert(_rawValue)}get value(){return track(toRaw(this),"get","value"),this._value}set value(newVal){hasChanged(toRaw(newVal),this._rawValue)&&(this._rawValue=newVal,this._value=this._shallow?newVal:convert(newVal),trigger(toRaw(this),"set","value",newVal))}}function createRef(rawValue,shallow=!1){return isRef(rawValue)?rawValue:new RefImpl(rawValue,shallow)}function triggerRef(ref){trigger(ref,"set","value",ref.value)}function unref(ref){return isRef(ref)?ref.value:ref}const shallowUnwrapHandlers={get:(target,key,receiver)=>unref(Reflect.get(target,key,receiver)),set:(target,key,value,receiver)=>{const oldValue=target[key];return isRef(oldValue)&&!isRef(value)?(oldValue.value=value,!0):Reflect.set(target,key,value,receiver)}};function proxyRefs(objectWithRefs){return isReactive(objectWithRefs)?objectWithRefs:new Proxy(objectWithRefs,shallowUnwrapHandlers)}class CustomRefImpl{constructor(factory){this.__v_isRef=!0;const{get:get,set:set}=factory(()=>track(this,"get","value"),()=>trigger(this,"set","value"));this._get=get,this._set=set}get value(){return this._get()}set value(newVal){this._set(newVal)}}function customRef(factory){return new CustomRefImpl(factory)}function toRefs(object){isProxy(object)||console.warn("toRefs() expects a reactive object but received a plain one.");const ret=isArray(object)?new Array(object.length):{};for(const key in object)ret[key]=toRef(object,key);return ret}class ObjectRefImpl{constructor(_object,_key){this._object=_object,this._key=_key,this.__v_isRef=!0}get value(){return this._object[this._key]}set value(newVal){this._object[this._key]=newVal}}function toRef(object,key){return isRef(object[key])?object[key]:new ObjectRefImpl(object,key)}class ComputedRefImpl{constructor(getter,_setter,isReadonly){this._setter=_setter,this._dirty=!0,this.__v_isRef=!0,this.effect=effect(getter,{lazy:!0,scheduler:()=>{this._dirty||(this._dirty=!0,trigger(toRaw(this),"set","value"))}}),this.__v_isReadonly=isReadonly}get value(){return this._dirty&&(this._value=this.effect(),this._dirty=!1),track(toRaw(this),"get","value"),this._value}set value(newValue){this._setter(newValue)}}function computed(getterOrOptions){let getter,setter;return isFunction(getterOrOptions)?(getter=getterOrOptions,setter=()=>{console.warn("Write operation failed: computed value is readonly")}):(getter=getterOrOptions.get,setter=getterOrOptions.set),new ComputedRefImpl(getter,setter,isFunction(getterOrOptions)||!getterOrOptions.set)}const stack=[];function pushWarningContext(vnode){stack.push(vnode)}function popWarningContext(){stack.pop()}function warn(msg,...args){pauseTracking();const instance=stack.length?stack[stack.length-1].component:null,appWarnHandler=instance&&instance.appContext.config.warnHandler,trace=getComponentTrace();if(appWarnHandler)callWithErrorHandling(appWarnHandler,instance,11,[msg+args.join(""),instance&&instance.proxy,trace.map(({vnode:vnode})=>`at <${formatComponentName(instance,vnode.type)}>`).join("\n"),trace]);else{const warnArgs=[`[Vue warn]: ${msg}`,...args];trace.length&&warnArgs.push("\n",...formatTrace(trace)),console.warn(...warnArgs)}resetTracking()}function getComponentTrace(){let currentVNode=stack[stack.length-1];if(!currentVNode)return[];const normalizedStack=[];for(;currentVNode;){const last=normalizedStack[0];last&&last.vnode===currentVNode?last.recurseCount++:normalizedStack.push({vnode:currentVNode,recurseCount:0});const parentInstance=currentVNode.component&&currentVNode.component.parent;currentVNode=parentInstance&&parentInstance.vnode}return normalizedStack}function formatTrace(trace){const logs=[];return trace.forEach((entry,i)=>{logs.push(...0===i?[]:["\n"],...formatTraceEntry(entry))}),logs}function formatTraceEntry({vnode:vnode,recurseCount:recurseCount}){const postfix=recurseCount>0?`... (${recurseCount} recursive calls)`:"",isRoot=!!vnode.component&&null==vnode.component.parent,open=` at <${formatComponentName(vnode.component,vnode.type,isRoot)}`,close=">"+postfix;return vnode.props?[open,...formatProps(vnode.props),close]:[open+close]}function formatProps(props){const res=[],keys=Object.keys(props);return keys.slice(0,3).forEach(key=>{res.push(...formatProp(key,props[key]))}),keys.length>3&&res.push(" ..."),res}function formatProp(key,value,raw){return isString(value)?(value=JSON.stringify(value),raw?value:[`${key}=${value}`]):"number"==typeof value||"boolean"==typeof value||null==value?raw?value:[`${key}=${value}`]:isRef(value)?(value=formatProp(key,toRaw(value.value),!0),raw?value:[`${key}=Ref<`,value,">"]):isFunction(value)?[`${key}=fn${value.name?`<${value.name}>`:""}`]:(value=toRaw(value),raw?value:[`${key}=`,value])}const ErrorTypeStrings={bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next"};function callWithErrorHandling(fn,instance,type,args){let res;try{res=args?fn(...args):fn()}catch(err){handleError(err,instance,type)}return res}function callWithAsyncErrorHandling(fn,instance,type,args){if(isFunction(fn)){const res=callWithErrorHandling(fn,instance,type,args);return res&&isPromise(res)&&res.catch(err=>{handleError(err,instance,type)}),res}const values=[];for(let i=0;i<fn.length;i++)values.push(callWithAsyncErrorHandling(fn[i],instance,type,args));return values}function handleError(err,instance,type,throwInDev=!0){const contextVNode=instance?instance.vnode:null;if(instance){let cur=instance.parent;const exposedInstance=instance.proxy,errorInfo=ErrorTypeStrings[type];for(;cur;){const errorCapturedHooks=cur.ec;if(errorCapturedHooks)for(let i=0;i<errorCapturedHooks.length;i++)if(errorCapturedHooks[i](err,exposedInstance,errorInfo))return;cur=cur.parent}const appErrorHandler=instance.appContext.config.errorHandler;if(appErrorHandler)return void callWithErrorHandling(appErrorHandler,null,10,[err,exposedInstance,errorInfo])}logError(err,type,contextVNode,throwInDev)}function logError(err,type,contextVNode,throwInDev=!0){{const info=ErrorTypeStrings[type];if(contextVNode&&pushWarningContext(contextVNode),warn(`Unhandled error${info?` during execution of ${info}`:""}`),contextVNode&&popWarningContext(),throwInDev)throw err;console.error(err)}}let isFlushing=!1,isFlushPending=!1;const queue=[];let flushIndex=0;const pendingPreFlushCbs=[];let activePreFlushCbs=null,preFlushIndex=0;const pendingPostFlushCbs=[];let activePostFlushCbs=null,postFlushIndex=0;const resolvedPromise=Promise.resolve();let currentFlushPromise=null,currentPreFlushParentJob=null;const RECURSION_LIMIT=100;function nextTick(fn){const p=currentFlushPromise||resolvedPromise;return fn?p.then(fn):p}function queueJob(job){queue.length&&queue.includes(job,isFlushing&&job.allowRecurse?flushIndex+1:flushIndex)||job===currentPreFlushParentJob||(queue.push(job),queueFlush())}function queueFlush(){isFlushing||isFlushPending||(isFlushPending=!0,currentFlushPromise=resolvedPromise.then(flushJobs))}function invalidateJob(job){const i=queue.indexOf(job);i>-1&&(queue[i]=null)}function queueCb(cb,activeQueue,pendingQueue,index){isArray(cb)?pendingQueue.push(...cb):activeQueue&&activeQueue.includes(cb,cb.allowRecurse?index+1:index)||pendingQueue.push(cb),queueFlush()}function queuePreFlushCb(cb){queueCb(cb,activePreFlushCbs,pendingPreFlushCbs,preFlushIndex)}function queuePostFlushCb(cb){queueCb(cb,activePostFlushCbs,pendingPostFlushCbs,postFlushIndex)}function flushPreFlushCbs(seen,parentJob=null){if(pendingPreFlushCbs.length){for(currentPreFlushParentJob=parentJob,activePreFlushCbs=[...new Set(pendingPreFlushCbs)],pendingPreFlushCbs.length=0,seen=seen||new Map,preFlushIndex=0;preFlushIndex<activePreFlushCbs.length;preFlushIndex++)checkRecursiveUpdates(seen,activePreFlushCbs[preFlushIndex]),activePreFlushCbs[preFlushIndex]();activePreFlushCbs=null,preFlushIndex=0,currentPreFlushParentJob=null,flushPreFlushCbs(seen,parentJob)}}function flushPostFlushCbs(seen){if(pendingPostFlushCbs.length){const deduped=[...new Set(pendingPostFlushCbs)];if(pendingPostFlushCbs.length=0,activePostFlushCbs)return void activePostFlushCbs.push(...deduped);for(activePostFlushCbs=deduped,seen=seen||new Map,activePostFlushCbs.sort((a,b)=>getId(a)-getId(b)),postFlushIndex=0;postFlushIndex<activePostFlushCbs.length;postFlushIndex++)checkRecursiveUpdates(seen,activePostFlushCbs[postFlushIndex]),activePostFlushCbs[postFlushIndex]();activePostFlushCbs=null,postFlushIndex=0}}const getId=job=>null==job.id?1/0:job.id;function flushJobs(seen){isFlushPending=!1,isFlushing=!0,flushPreFlushCbs(seen=seen||new Map),queue.sort((a,b)=>getId(a)-getId(b));try{for(flushIndex=0;flushIndex<queue.length;flushIndex++){const job=queue[flushIndex];job&&(checkRecursiveUpdates(seen,job),callWithErrorHandling(job,null,14))}}finally{flushIndex=0,queue.length=0,flushPostFlushCbs(seen),isFlushing=!1,currentFlushPromise=null,(queue.length||pendingPostFlushCbs.length)&&flushJobs(seen)}}function checkRecursiveUpdates(seen,fn){if(seen.has(fn)){const count=seen.get(fn);if(count>100)throw new Error("Maximum recursive updates exceeded. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.");seen.set(fn,count+1)}else seen.set(fn,1)}let isHmrUpdating=!1;const hmrDirtyComponents=new Set;{const globalObject="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{};globalObject.__VUE_HMR_RUNTIME__={createRecord:tryWrap(createRecord),rerender:tryWrap(rerender),reload:tryWrap(reload)}}const map=new Map;function registerHMR(instance){const id=instance.type.__hmrId;let record=map.get(id);record||(createRecord(id),record=map.get(id)),record.add(instance)}function unregisterHMR(instance){map.get(instance.type.__hmrId).delete(instance)}function createRecord(id){return!map.has(id)&&(map.set(id,new Set),!0)}function rerender(id,newRender){const record=map.get(id);record&&Array.from(record).forEach(instance=>{newRender&&(instance.render=newRender),instance.renderCache=[],isHmrUpdating=!0,instance.update(),isHmrUpdating=!1})}function reload(id,newComp){const record=map.get(id);record&&Array.from(record).forEach(instance=>{const comp=instance.type;if(!hmrDirtyComponents.has(comp)){newComp=isClassComponent(newComp)?newComp.__vccOpts:newComp,extend(comp,newComp);for(const key in comp)key in newComp||delete comp[key];hmrDirtyComponents.add(comp),queuePostFlushCb(()=>{hmrDirtyComponents.delete(comp)})}instance.parent?queueJob(instance.parent.update):instance.appContext.reload?instance.appContext.reload():"undefined"!=typeof window?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required.")})}function tryWrap(fn){return(id,arg)=>{try{return fn(id,arg)}catch(e){console.error(e),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}function setDevtoolsHook(hook){exports.devtools=hook}function devtoolsInitApp(app,version){exports.devtools&&exports.devtools.emit("app:init",app,version,{Fragment:Fragment,Text:Text,Comment:Comment,Static:Static})}function devtoolsUnmountApp(app){exports.devtools&&exports.devtools.emit("app:unmount",app)}const devtoolsComponentAdded=createDevtoolsComponentHook("component:added"),devtoolsComponentUpdated=createDevtoolsComponentHook("component:updated"),devtoolsComponentRemoved=createDevtoolsComponentHook("component:removed");function createDevtoolsComponentHook(hook){return component=>{exports.devtools&&exports.devtools.emit(hook,component.appContext.app,component.uid,component.parent?component.parent.uid:void 0)}}function devtoolsComponentEmit(component,event,params){exports.devtools&&exports.devtools.emit("component:emit",component.appContext.app,component,event,params)}function emit(instance,event,...args){const props=instance.vnode.props||EMPTY_OBJ;{const{emitsOptions:emitsOptions,propsOptions:[propsOptions]}=instance;if(emitsOptions)if(event in emitsOptions){const validator=emitsOptions[event];if(isFunction(validator)){const isValid=validator(...args);isValid||warn(`Invalid event arguments: event validation failed for event "${event}".`)}}else propsOptions&&"on"+capitalize(event)in propsOptions||warn(`Component emitted event "${event}" but it is neither declared in `+`the emits option nor as an "on${capitalize(event)}" prop.`)}devtoolsComponentEmit(instance,event,args);let handlerName=`on${capitalize(event)}`,handler=props[handlerName];if(!handler&&event.startsWith("update:")&&(handlerName=`on${capitalize(hyphenate(event))}`,handler=props[handlerName]),!handler)if(handler=props[handlerName+"Once"],instance.emitted){if(instance.emitted[handlerName])return}else(instance.emitted={})[handlerName]=!0;handler&&callWithAsyncErrorHandling(handler,instance,6,args)}function normalizeEmitsOptions(comp,appContext,asMixin=!1){const appId=appContext.app?appContext.app._uid:-1,cache=comp.__emits||(comp.__emits={}),cached=cache[appId];if(void 0!==cached)return cached;const raw=comp.emits;let normalized={},hasExtends=!1;if(!isFunction(comp)){const extendEmits=raw=>{hasExtends=!0,extend(normalized,normalizeEmitsOptions(raw,appContext,!0))};!asMixin&&appContext.mixins.length&&appContext.mixins.forEach(extendEmits),comp.extends&&extendEmits(comp.extends),comp.mixins&&comp.mixins.forEach(extendEmits)}return raw||hasExtends?(isArray(raw)?raw.forEach(key=>normalized[key]=null):extend(normalized,raw),cache[appId]=normalized):cache[appId]=null}function isEmitListener(options,key){return!(!options||!isOn(key))&&(key=key.replace(/Once$/,""),hasOwn(options,key[2].toLowerCase()+key.slice(3))||hasOwn(options,key.slice(2)))}let currentRenderingInstance=null;function setCurrentRenderingInstance(instance){currentRenderingInstance=instance}let accessedAttrs=!1;function markAttrsAccessed(){accessedAttrs=!0}function renderComponentRoot(instance){const{type:Component,vnode:vnode,proxy:proxy,withProxy:withProxy,props:props,propsOptions:[propsOptions],slots:slots,attrs:attrs,emit:emit,render:render,renderCache:renderCache,data:data,setupState:setupState,ctx:ctx}=instance;let result;currentRenderingInstance=instance,accessedAttrs=!1;try{let fallthroughAttrs;if(4&vnode.shapeFlag){const proxyToUse=withProxy||proxy;result=normalizeVNode(render.call(proxyToUse,proxyToUse,renderCache,props,setupState,data,ctx)),fallthroughAttrs=attrs}else{const render=Component;attrs===props&&markAttrsAccessed(),result=normalizeVNode(render.length>1?render(props,{get attrs(){return markAttrsAccessed(),attrs},slots:slots,emit:emit}):render(props,null)),fallthroughAttrs=Component.props?attrs:getFunctionalFallthrough(attrs)}let root=result,setRoot=void 0;if([root,setRoot]=getChildRoot(result),!1!==Component.inheritAttrs&&fallthroughAttrs){const keys=Object.keys(fallthroughAttrs),{shapeFlag:shapeFlag}=root;if(keys.length)if(1&shapeFlag||6&shapeFlag)propsOptions&&keys.some(isModelListener)&&(fallthroughAttrs=filterModelListeners(fallthroughAttrs,propsOptions)),root=cloneVNode(root,fallthroughAttrs);else if(!accessedAttrs&&root.type!==Comment){const allAttrs=Object.keys(attrs),eventAttrs=[],extraAttrs=[];for(let i=0,l=allAttrs.length;i<l;i++){const key=allAttrs[i];isOn(key)?isModelListener(key)||eventAttrs.push(key[2].toLowerCase()+key.slice(3)):extraAttrs.push(key)}extraAttrs.length&&warn("Extraneous non-props attributes ("+`${extraAttrs.join(", ")}) `+"were passed to component but could not be automatically inherited because component renders fragment or text root nodes."),eventAttrs.length&&warn("Extraneous non-emits event listeners ("+`${eventAttrs.join(", ")}) `+'were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.')}}vnode.dirs&&(isElementRoot(root)||warn("Runtime directive used on component with non-element root node. The directives will not function as intended."),root.dirs=vnode.dirs),vnode.transition&&(isElementRoot(root)||warn("Component inside <Transition> renders non-element root node that cannot be animated."),root.transition=vnode.transition),setRoot?setRoot(root):result=root}catch(err){handleError(err,instance,1),result=createVNode(Comment)}return currentRenderingInstance=null,result}const getChildRoot=vnode=>{if(vnode.type!==Fragment)return[vnode,void 0];const rawChildren=vnode.children,dynamicChildren=vnode.dynamicChildren,childRoot=filterSingleRoot(rawChildren);if(!childRoot)return[vnode,void 0];const index=rawChildren.indexOf(childRoot),dynamicIndex=dynamicChildren?dynamicChildren.indexOf(childRoot):-1,setRoot=updatedRoot=>{rawChildren[index]=updatedRoot,dynamicIndex>-1?dynamicChildren[dynamicIndex]=updatedRoot:dynamicChildren&&updatedRoot.patchFlag>0&&dynamicChildren.push(updatedRoot)};return[normalizeVNode(childRoot),setRoot]};function filterSingleRoot(children){const filtered=children.filter(child=>!(isVNode(child)&&child.type===Comment&&"v-if"!==child.children));return 1===filtered.length&&isVNode(filtered[0])?filtered[0]:null}const getFunctionalFallthrough=attrs=>{let res;for(const key in attrs)("class"===key||"style"===key||isOn(key))&&((res||(res={}))[key]=attrs[key]);return res},filterModelListeners=(attrs,props)=>{const res={};for(const key in attrs)isModelListener(key)&&key.slice(9)in props||(res[key]=attrs[key]);return res},isElementRoot=vnode=>6&vnode.shapeFlag||1&vnode.shapeFlag||vnode.type===Comment;function shouldUpdateComponent(prevVNode,nextVNode,optimized){const{props:prevProps,children:prevChildren,component:component}=prevVNode,{props:nextProps,children:nextChildren,patchFlag:patchFlag}=nextVNode,emits=component.emitsOptions;if((prevChildren||nextChildren)&&isHmrUpdating)return!0;if(nextVNode.dirs||nextVNode.transition)return!0;if(!(optimized&&patchFlag>0))return!(!prevChildren&&!nextChildren||nextChildren&&nextChildren.$stable)||prevProps!==nextProps&&(prevProps?!nextProps||hasPropsChanged(prevProps,nextProps,emits):!!nextProps);if(1024&patchFlag)return!0;if(16&patchFlag)return prevProps?hasPropsChanged(prevProps,nextProps,emits):!!nextProps;if(8&patchFlag){const dynamicProps=nextVNode.dynamicProps;for(let i=0;i<dynamicProps.length;i++){const key=dynamicProps[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emits,key))return!0}}return!1}function hasPropsChanged(prevProps,nextProps,emitsOptions){const nextKeys=Object.keys(nextProps);if(nextKeys.length!==Object.keys(prevProps).length)return!0;for(let i=0;i<nextKeys.length;i++){const key=nextKeys[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emitsOptions,key))return!0}return!1}function updateHOCHostEl({vnode:vnode,parent:parent},el){for(;parent&&parent.subTree===vnode;)(vnode=parent.vnode).el=el,parent=parent.parent}const isSuspense=type=>type.__isSuspense,SuspenseImpl={__isSuspense:!0,process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized,rendererInternals){null==n1?mountSuspense(n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized,rendererInternals):patchSuspense(n1,n2,container,anchor,parentComponent,isSVG,optimized,rendererInternals)},hydrate:hydrateSuspense,create:createSuspenseBoundary},Suspense=SuspenseImpl;function mountSuspense(vnode,container,anchor,parentComponent,parentSuspense,isSVG,optimized,rendererInternals){const{p:patch,o:{createElement:createElement}}=rendererInternals,hiddenContainer=createElement("div"),suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,container,hiddenContainer,anchor,isSVG,optimized,rendererInternals);patch(null,suspense.pendingBranch=vnode.ssContent,hiddenContainer,null,parentComponent,suspense,isSVG,optimized),suspense.deps>0?(patch(null,vnode.ssFallback,container,anchor,parentComponent,null,isSVG,optimized),setActiveBranch(suspense,vnode.ssFallback)):suspense.resolve()}function patchSuspense(n1,n2,container,anchor,parentComponent,isSVG,optimized,{p:patch,um:unmount,o:{createElement:createElement}}){const suspense=n2.suspense=n1.suspense;suspense.vnode=n2,n2.el=n1.el;const newBranch=n2.ssContent,newFallback=n2.ssFallback,{activeBranch:activeBranch,pendingBranch:pendingBranch,isInFallback:isInFallback,isHydrating:isHydrating}=suspense;if(pendingBranch)suspense.pendingBranch=newBranch,isSameVNodeType(newBranch,pendingBranch)?(patch(pendingBranch,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,optimized),suspense.deps<=0?suspense.resolve():isInFallback&&(patch(activeBranch,newFallback,container,anchor,parentComponent,null,isSVG,optimized),setActiveBranch(suspense,newFallback))):(suspense.pendingId++,isHydrating?(suspense.isHydrating=!1,suspense.activeBranch=pendingBranch):unmount(pendingBranch,parentComponent,suspense),suspense.deps=0,suspense.effects.length=0,suspense.hiddenContainer=createElement("div"),isInFallback?(patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,optimized),suspense.deps<=0?suspense.resolve():(patch(activeBranch,newFallback,container,anchor,parentComponent,null,isSVG,optimized),setActiveBranch(suspense,newFallback))):activeBranch&&isSameVNodeType(newBranch,activeBranch)?(patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,isSVG,optimized),suspense.resolve(!0)):(patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,optimized),suspense.deps<=0&&suspense.resolve()));else if(activeBranch&&isSameVNodeType(newBranch,activeBranch))patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,isSVG,optimized),setActiveBranch(suspense,newBranch);else{const onPending=n2.props&&n2.props.onPending;if(isFunction(onPending)&&onPending(),suspense.pendingBranch=newBranch,suspense.pendingId++,patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,optimized),suspense.deps<=0)suspense.resolve();else{const{timeout:timeout,pendingId:pendingId}=suspense;timeout>0?setTimeout(()=>{suspense.pendingId===pendingId&&suspense.fallback(newFallback)},timeout):0===timeout&&suspense.fallback(newFallback)}}}let hasWarned=!1;function createSuspenseBoundary(vnode,parent,parentComponent,container,hiddenContainer,anchor,isSVG,optimized,rendererInternals,isHydrating=!1){hasWarned||(hasWarned=!0,console[console.info?"info":"log"]("<Suspense> is an experimental feature and its API will likely change."));const{p:patch,m:move,um:unmount,n:next,o:{parentNode:parentNode,remove:remove}}=rendererInternals,timeout=toNumber(vnode.props&&vnode.props.timeout),suspense={vnode:vnode,parent:parent,parentComponent:parentComponent,isSVG:isSVG,optimized:optimized,container:container,hiddenContainer:hiddenContainer,anchor:anchor,deps:0,pendingId:0,timeout:"number"==typeof timeout?timeout:-1,activeBranch:null,pendingBranch:null,isInFallback:!0,isHydrating:isHydrating,isUnmounted:!1,effects:[],resolve(resume=!1){if(!resume&&!suspense.pendingBranch)throw new Error("suspense.resolve() is called without a pending branch.");if(suspense.isUnmounted)throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.");const{vnode:vnode,activeBranch:activeBranch,pendingBranch:pendingBranch,pendingId:pendingId,effects:effects,parentComponent:parentComponent,container:container}=suspense;if(suspense.isHydrating)suspense.isHydrating=!1;else if(!resume){const delayEnter=activeBranch&&pendingBranch.transition&&"out-in"===pendingBranch.transition.mode;delayEnter&&(activeBranch.transition.afterLeave=()=>{pendingId===suspense.pendingId&&move(pendingBranch,container,anchor,0)});let{anchor:anchor}=suspense;activeBranch&&(anchor=next(activeBranch),unmount(activeBranch,parentComponent,suspense,!0)),delayEnter||move(pendingBranch,container,anchor,0)}setActiveBranch(suspense,pendingBranch),suspense.pendingBranch=null,suspense.isInFallback=!1;let parent=suspense.parent,hasUnresolvedAncestor=!1;for(;parent;){if(parent.pendingBranch){parent.effects.push(...effects),hasUnresolvedAncestor=!0;break}parent=parent.parent}hasUnresolvedAncestor||queuePostFlushCb(effects),suspense.effects=[];const onResolve=vnode.props&&vnode.props.onResolve;isFunction(onResolve)&&onResolve()},fallback(fallbackVNode){if(!suspense.pendingBranch)return;const{vnode:vnode,activeBranch:activeBranch,parentComponent:parentComponent,container:container,isSVG:isSVG,optimized:optimized}=suspense,onFallback=vnode.props&&vnode.props.onFallback;isFunction(onFallback)&&onFallback();const anchor=next(activeBranch),mountFallback=()=>{suspense.isInFallback&&(patch(null,fallbackVNode,container,anchor,parentComponent,null,isSVG,optimized),setActiveBranch(suspense,fallbackVNode))},delayEnter=fallbackVNode.transition&&"out-in"===fallbackVNode.transition.mode;delayEnter&&(activeBranch.transition.afterLeave=mountFallback),unmount(activeBranch,parentComponent,null,!0),suspense.isInFallback=!0,delayEnter||mountFallback()},move(container,anchor,type){suspense.activeBranch&&move(suspense.activeBranch,container,anchor,type),suspense.container=container},next:()=>suspense.activeBranch&&next(suspense.activeBranch),registerDep(instance,setupRenderEffect){if(!suspense.pendingBranch)return;const hydratedEl=instance.vnode.el;suspense.deps++,instance.asyncDep.catch(err=>{handleError(err,instance,0)}).then(asyncSetupResult=>{if(instance.isUnmounted||suspense.isUnmounted||suspense.pendingId!==instance.suspenseId)return;suspense.deps--,instance.asyncResolved=!0;const{vnode:vnode}=instance;pushWarningContext(vnode),handleSetupResult(instance,asyncSetupResult),hydratedEl&&(vnode.el=hydratedEl);const placeholder=!hydratedEl&&instance.subTree.el;setupRenderEffect(instance,vnode,parentNode(hydratedEl||instance.subTree.el),hydratedEl?null:next(instance.subTree),suspense,isSVG,optimized),placeholder&&remove(placeholder),updateHOCHostEl(instance,vnode.el),popWarningContext(),0===suspense.deps&&suspense.resolve()})},unmount(parentSuspense,doRemove){suspense.isUnmounted=!0,suspense.activeBranch&&unmount(suspense.activeBranch,parentComponent,parentSuspense,doRemove),suspense.pendingBranch&&unmount(suspense.pendingBranch,parentComponent,parentSuspense,doRemove)}};return suspense}function hydrateSuspense(node,vnode,parentComponent,parentSuspense,isSVG,optimized,rendererInternals,hydrateNode){const suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,node.parentNode,document.createElement("div"),null,isSVG,optimized,rendererInternals,!0),result=hydrateNode(node,suspense.pendingBranch=vnode.ssContent,parentComponent,suspense,optimized);return 0===suspense.deps&&suspense.resolve(),result}function normalizeSuspenseChildren(vnode){const{shapeFlag:shapeFlag,children:children}=vnode;let content,fallback;return 32&shapeFlag?(content=normalizeSuspenseSlot(children.default),fallback=normalizeSuspenseSlot(children.fallback)):(content=normalizeSuspenseSlot(children),fallback=normalizeVNode(null)),{content:content,fallback:fallback}}function normalizeSuspenseSlot(s){if(isFunction(s)&&(s=s()),isArray(s)){const singleChild=filterSingleRoot(s);singleChild||warn("<Suspense> slots expect a single root node."),s=singleChild}return normalizeVNode(s)}function queueEffectWithSuspense(fn,suspense){suspense&&suspense.pendingBranch?isArray(fn)?suspense.effects.push(...fn):suspense.effects.push(fn):queuePostFlushCb(fn)}function setActiveBranch(suspense,branch){suspense.activeBranch=branch;const{vnode:vnode,parentComponent:parentComponent}=suspense,el=vnode.el=branch.el;parentComponent&&parentComponent.subTree===vnode&&(parentComponent.vnode.el=el,updateHOCHostEl(parentComponent,el))}let isRenderingCompiledSlot=0;const setCompiledSlotRendering=n=>isRenderingCompiledSlot+=n;function renderSlot(slots,name,props={},fallback){let slot=slots[name];slot&&slot.length>1&&(warn("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."),slot=()=>[]),isRenderingCompiledSlot++;const rendered=(openBlock(),createBlock(Fragment,{key:props.key},slot?slot(props):fallback?fallback():[],1===slots._?64:-2));return isRenderingCompiledSlot--,rendered}function withCtx(fn,ctx=currentRenderingInstance){if(!ctx)return fn;const renderFnWithContext=(...args)=>{isRenderingCompiledSlot||openBlock(!0);const owner=currentRenderingInstance;setCurrentRenderingInstance(ctx);const res=fn(...args);return setCurrentRenderingInstance(owner),isRenderingCompiledSlot||closeBlock(),res};return renderFnWithContext._c=!0,renderFnWithContext}let currentScopeId=null;const scopeIdStack=[];function pushScopeId(id){scopeIdStack.push(currentScopeId=id)}function popScopeId(){scopeIdStack.pop(),currentScopeId=scopeIdStack[scopeIdStack.length-1]||null}function withScopeId(id){return fn=>withCtx((function(){pushScopeId(id);const res=fn.apply(this,arguments);return popScopeId(),res}))}const isTeleport=type=>type.__isTeleport,isTeleportDisabled=props=>props&&(props.disabled||""===props.disabled),resolveTarget=(props,select)=>{const targetSelector=props&&props.to;if(isString(targetSelector)){if(select){const target=select(targetSelector);return target||warn(`Failed to locate Teleport target with selector "${targetSelector}". `+"Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree."),target}return warn("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"),null}return targetSelector||isTeleportDisabled(props)||warn(`Invalid Teleport target: ${targetSelector}`),targetSelector},TeleportImpl={__isTeleport:!0,process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized,internals){const{mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,o:{insert:insert,querySelector:querySelector,createText:createText,createComment:createComment}}=internals,disabled=isTeleportDisabled(n2.props),{shapeFlag:shapeFlag,children:children}=n2;if(null==n1){const placeholder=n2.el=createComment("teleport start"),mainAnchor=n2.anchor=createComment("teleport end");insert(placeholder,container,anchor),insert(mainAnchor,container,anchor);const target=n2.target=resolveTarget(n2.props,querySelector),targetAnchor=n2.targetAnchor=createText("");target?insert(targetAnchor,target):disabled||warn("Invalid Teleport target on mount:",target,`(${typeof target})`);const mount=(container,anchor)=>{16&shapeFlag&&mountChildren(children,container,anchor,parentComponent,parentSuspense,isSVG,optimized)};disabled?mount(container,mainAnchor):target&&mount(target,targetAnchor)}else{n2.el=n1.el;const mainAnchor=n2.anchor=n1.anchor,target=n2.target=n1.target,targetAnchor=n2.targetAnchor=n1.targetAnchor,wasDisabled=isTeleportDisabled(n1.props),currentContainer=wasDisabled?container:target,currentAnchor=wasDisabled?mainAnchor:targetAnchor;if(n2.dynamicChildren){if(patchBlockChildren(n1.dynamicChildren,n2.dynamicChildren,currentContainer,parentComponent,parentSuspense,isSVG),16&n2.shapeFlag){const oldChildren=n1.children,children=n2.children;for(let i=0;i<children.length;i++)children[i].el||(children[i].el=oldChildren[i].el)}}else optimized||patchChildren(n1,n2,currentContainer,currentAnchor,parentComponent,parentSuspense,isSVG);if(disabled)wasDisabled||moveTeleport(n2,container,mainAnchor,internals,1);else if((n2.props&&n2.props.to)!==(n1.props&&n1.props.to)){const nextTarget=n2.target=resolveTarget(n2.props,querySelector);nextTarget?moveTeleport(n2,nextTarget,null,internals,0):warn("Invalid Teleport target on update:",target,`(${typeof target})`)}else wasDisabled&&moveTeleport(n2,target,targetAnchor,internals,1)}},remove(vnode,{r:remove,o:{remove:hostRemove}}){const{shapeFlag:shapeFlag,children:children,anchor:anchor}=vnode;if(hostRemove(anchor),16&shapeFlag)for(let i=0;i<children.length;i++)remove(children[i])},move:moveTeleport,hydrate:hydrateTeleport};function moveTeleport(vnode,container,parentAnchor,{o:{insert:insert},m:move},moveType=2){0===moveType&&insert(vnode.targetAnchor,container,parentAnchor);const{el:el,anchor:anchor,shapeFlag:shapeFlag,children:children,props:props}=vnode,isReorder=2===moveType;if(isReorder&&insert(el,container,parentAnchor),(!isReorder||isTeleportDisabled(props))&&16&shapeFlag)for(let i=0;i<children.length;i++)move(children[i],container,parentAnchor,2);isReorder&&insert(anchor,container,parentAnchor)}function hydrateTeleport(node,vnode,parentComponent,parentSuspense,optimized,{o:{nextSibling:nextSibling,parentNode:parentNode,querySelector:querySelector}},hydrateChildren){const target=vnode.target=resolveTarget(vnode.props,querySelector);if(target){const targetNode=target._lpa||target.firstChild;16&vnode.shapeFlag&&(isTeleportDisabled(vnode.props)?(vnode.anchor=hydrateChildren(nextSibling(node),vnode,parentNode(node),parentComponent,parentSuspense,optimized),vnode.targetAnchor=targetNode):(vnode.anchor=nextSibling(node),vnode.targetAnchor=hydrateChildren(targetNode,vnode,target,parentComponent,parentSuspense,optimized)),target._lpa=vnode.targetAnchor&&nextSibling(vnode.targetAnchor))}return vnode.anchor&&nextSibling(vnode.anchor)}const Teleport=TeleportImpl,COMPONENTS="components",DIRECTIVES="directives";function resolveComponent(name){return resolveAsset(COMPONENTS,name)||name}const NULL_DYNAMIC_COMPONENT=Symbol();function resolveDynamicComponent(component){return isString(component)?resolveAsset(COMPONENTS,component,!1)||component:component||NULL_DYNAMIC_COMPONENT}function resolveDirective(name){return resolveAsset(DIRECTIVES,name)}function resolveAsset(type,name,warnMissing=!0){const instance=currentRenderingInstance||currentInstance;if(instance){const Component=instance.type;if(type===COMPONENTS){const selfName=Component.displayName||Component.name;if(selfName&&(selfName===name||selfName===camelize(name)||selfName===capitalize(camelize(name))))return Component}const res=resolve(instance[type]||Component[type],name)||resolve(instance.appContext[type],name);return warnMissing&&!res&&warn(`Failed to resolve ${type.slice(0,-1)}: ${name}`),res}warn(`resolve${capitalize(type.slice(0,-1))} `+"can only be used in render() or setup().")}function resolve(registry,name){return registry&&(registry[name]||registry[camelize(name)]||registry[capitalize(camelize(name))])}const Fragment=Symbol("Fragment"),Text=Symbol("Text"),Comment=Symbol("Comment"),Static=Symbol("Static"),blockStack=[];let currentBlock=null;function openBlock(disableTracking=!1){blockStack.push(currentBlock=disableTracking?null:[])}function closeBlock(){blockStack.pop(),currentBlock=blockStack[blockStack.length-1]||null}let shouldTrack$1=1,vnodeArgsTransformer;function setBlockTracking(value){shouldTrack$1+=value}function createBlock(type,props,children,patchFlag,dynamicProps){const vnode=createVNode(type,props,children,patchFlag,dynamicProps,!0);return vnode.dynamicChildren=currentBlock||EMPTY_ARR,closeBlock(),shouldTrack$1>0&&currentBlock&&currentBlock.push(vnode),vnode}function isVNode(value){return!!value&&!0===value.__v_isVNode}function isSameVNodeType(n1,n2){return!(6&n2.shapeFlag&&hmrDirtyComponents.has(n2.type))&&(n1.type===n2.type&&n1.key===n2.key)}function transformVNodeArgs(transformer){vnodeArgsTransformer=transformer}const createVNodeWithArgsTransform=(...args)=>_createVNode(...vnodeArgsTransformer?vnodeArgsTransformer(args,currentRenderingInstance):args),InternalObjectKey="__vInternal",normalizeKey=({key:key})=>null!=key?key:null,normalizeRef=({ref:ref})=>null!=ref?isArray(ref)?ref:{i:currentRenderingInstance,r:ref}:null,createVNode=createVNodeWithArgsTransform;function _createVNode(type,props=null,children=null,patchFlag=0,dynamicProps=null,isBlockNode=!1){if(type&&type!==NULL_DYNAMIC_COMPONENT||(type||warn(`Invalid vnode type when creating vnode: ${type}.`),type=Comment),isVNode(type)){const cloned=cloneVNode(type,props,!0);return children&&normalizeChildren(cloned,children),cloned}if(isClassComponent(type)&&(type=type.__vccOpts),props){(isProxy(props)||"__vInternal"in props)&&(props=extend({},props));let{class:klass,style:style}=props;klass&&!isString(klass)&&(props.class=normalizeClass(klass)),isObject(style)&&(isProxy(style)&&!isArray(style)&&(style=extend({},style)),props.style=normalizeStyle(style))}const shapeFlag=isString(type)?1:isSuspense(type)?128:isTeleport(type)?64:isObject(type)?4:isFunction(type)?2:0;4&shapeFlag&&isProxy(type)&&warn("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.","\nComponent that was made reactive: ",type=toRaw(type));const vnode={__v_isVNode:!0,__v_skip:!0,type:type,props:props,key:props&&normalizeKey(props),ref:props&&normalizeRef(props),scopeId:currentScopeId,children:null,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:shapeFlag,patchFlag:patchFlag,dynamicProps:dynamicProps,dynamicChildren:null,appContext:null};if(vnode.key!=vnode.key&&warn("VNode created with invalid key (NaN). VNode type:",vnode.type),normalizeChildren(vnode,children),128&shapeFlag){const{content:content,fallback:fallback}=normalizeSuspenseChildren(vnode);vnode.ssContent=content,vnode.ssFallback=fallback}return shouldTrack$1>0&&!isBlockNode&&currentBlock&&(patchFlag>0||6&shapeFlag)&&32!==patchFlag&&currentBlock.push(vnode),vnode}function cloneVNode(vnode,extraProps,mergeRef=!1){const{props:props,ref:ref,patchFlag:patchFlag}=vnode,mergedProps=extraProps?mergeProps(props||{},extraProps):props;return{__v_isVNode:!0,__v_skip:!0,type:vnode.type,props:mergedProps,key:mergedProps&&normalizeKey(mergedProps),ref:extraProps&&extraProps.ref?mergeRef&&ref?isArray(ref)?ref.concat(normalizeRef(extraProps)):[ref,normalizeRef(extraProps)]:normalizeRef(extraProps):ref,scopeId:vnode.scopeId,children:vnode.children,target:vnode.target,targetAnchor:vnode.targetAnchor,staticCount:vnode.staticCount,shapeFlag:vnode.shapeFlag,patchFlag:extraProps&&vnode.type!==Fragment?-1===patchFlag?16:16|patchFlag:patchFlag,dynamicProps:vnode.dynamicProps,dynamicChildren:vnode.dynamicChildren,appContext:vnode.appContext,dirs:vnode.dirs,transition:vnode.transition,component:vnode.component,suspense:vnode.suspense,ssContent:vnode.ssContent&&cloneVNode(vnode.ssContent),ssFallback:vnode.ssFallback&&cloneVNode(vnode.ssFallback),el:vnode.el,anchor:vnode.anchor}}function createTextVNode(text=" ",flag=0){return createVNode(Text,null,text,flag)}function createStaticVNode(content,numberOfNodes){const vnode=createVNode(Static,null,content);return vnode.staticCount=numberOfNodes,vnode}function createCommentVNode(text="",asBlock=!1){return asBlock?(openBlock(),createBlock(Comment,null,text)):createVNode(Comment,null,text)}function normalizeVNode(child){return null==child||"boolean"==typeof child?createVNode(Comment):isArray(child)?createVNode(Fragment,null,child):"object"==typeof child?null===child.el?child:cloneVNode(child):createVNode(Text,null,String(child))}function cloneIfMounted(child){return null===child.el?child:cloneVNode(child)}function normalizeChildren(vnode,children){let type=0;const{shapeFlag:shapeFlag}=vnode;if(null==children)children=null;else if(isArray(children))type=16;else if("object"==typeof children){if(1&shapeFlag||64&shapeFlag){const slot=children.default;return void(slot&&(slot._c&&setCompiledSlotRendering(1),normalizeChildren(vnode,slot()),slot._c&&setCompiledSlotRendering(-1)))}{type=32;const slotFlag=children._;slotFlag||"__vInternal"in children?3===slotFlag&&currentRenderingInstance&&(1024&currentRenderingInstance.vnode.patchFlag?(children._=2,vnode.patchFlag|=1024):children._=1):children._ctx=currentRenderingInstance}}else isFunction(children)?(children={default:children,_ctx:currentRenderingInstance},type=32):(children=String(children),64&shapeFlag?(type=16,children=[createTextVNode(children)]):type=8);vnode.children=children,vnode.shapeFlag|=type}function mergeProps(...args){const ret=extend({},args[0]);for(let i=1;i<args.length;i++){const toMerge=args[i];for(const key in toMerge)if("class"===key)ret.class!==toMerge.class&&(ret.class=normalizeClass([ret.class,toMerge.class]));else if("style"===key)ret.style=normalizeStyle([ret.style,toMerge.style]);else if(isOn(key)){const existing=ret[key],incoming=toMerge[key];existing!==incoming&&(ret[key]=existing?[].concat(existing,toMerge[key]):incoming)}else ret[key]=toMerge[key]}return ret}function initProps(instance,rawProps,isStateful,isSSR=!1){const props={},attrs={};def(attrs,"__vInternal",1),setFullProps(instance,rawProps,props,attrs),validateProps(props,instance),isStateful?instance.props=isSSR?props:shallowReactive(props):instance.type.props?instance.props=props:instance.props=attrs,instance.attrs=attrs}function updateProps(instance,rawProps,rawPrevProps,optimized){const{props:props,attrs:attrs,vnode:{patchFlag:patchFlag}}=instance,rawCurrentProps=toRaw(props),[options]=instance.propsOptions;if(instance.type.__hmrId||!(optimized||patchFlag>0)||16&patchFlag){let kebabKey;setFullProps(instance,rawProps,props,attrs);for(const key in rawCurrentProps)rawProps&&(hasOwn(rawProps,key)||(kebabKey=hyphenate(key))!==key&&hasOwn(rawProps,kebabKey))||(options?!rawPrevProps||void 0===rawPrevProps[key]&&void 0===rawPrevProps[kebabKey]||(props[key]=resolvePropValue(options,rawProps||EMPTY_OBJ,key,void 0,instance)):delete props[key]);if(attrs!==rawCurrentProps)for(const key in attrs)rawProps&&hasOwn(rawProps,key)||delete attrs[key]}else if(8&patchFlag){const propsToUpdate=instance.vnode.dynamicProps;for(let i=0;i<propsToUpdate.length;i++){const key=propsToUpdate[i],value=rawProps[key];if(options)if(hasOwn(attrs,key))attrs[key]=value;else{const camelizedKey=camelize(key);props[camelizedKey]=resolvePropValue(options,rawCurrentProps,camelizedKey,value,instance)}else attrs[key]=value}}trigger(instance,"set","$attrs"),rawProps&&validateProps(props,instance)}function setFullProps(instance,rawProps,props,attrs){const[options,needCastKeys]=instance.propsOptions;if(rawProps)for(const key in rawProps){const value=rawProps[key];if(isReservedProp(key))continue;let camelKey;options&&hasOwn(options,camelKey=camelize(key))?props[camelKey]=value:isEmitListener(instance.emitsOptions,key)||(attrs[key]=value)}if(needCastKeys){const rawCurrentProps=toRaw(props);for(let i=0;i<needCastKeys.length;i++){const key=needCastKeys[i];props[key]=resolvePropValue(options,rawCurrentProps,key,rawCurrentProps[key],instance)}}}function resolvePropValue(options,props,key,value,instance){const opt=options[key];if(null!=opt){const hasDefault=hasOwn(opt,"default");if(hasDefault&&void 0===value){const defaultValue=opt.default;opt.type!==Function&&isFunction(defaultValue)?(setCurrentInstance(instance),value=defaultValue(props),setCurrentInstance(null)):value=defaultValue}opt[0]&&(hasOwn(props,key)||hasDefault?!opt[1]||""!==value&&value!==hyphenate(key)||(value=!0):value=!1)}return value}function normalizePropsOptions(comp,appContext,asMixin=!1){const appId=appContext.app?appContext.app._uid:-1,cache=comp.__props||(comp.__props={}),cached=cache[appId];if(cached)return cached;const raw=comp.props,normalized={},needCastKeys=[];let hasExtends=!1;if(!isFunction(comp)){const extendProps=raw=>{hasExtends=!0;const[props,keys]=normalizePropsOptions(raw,appContext,!0);extend(normalized,props),keys&&needCastKeys.push(...keys)};!asMixin&&appContext.mixins.length&&appContext.mixins.forEach(extendProps),comp.extends&&extendProps(comp.extends),comp.mixins&&comp.mixins.forEach(extendProps)}if(!raw&&!hasExtends)return cache[appId]=EMPTY_ARR;if(isArray(raw))for(let i=0;i<raw.length;i++){isString(raw[i])||warn("props must be strings when using array syntax.",raw[i]);const normalizedKey=camelize(raw[i]);validatePropName(normalizedKey)&&(normalized[normalizedKey]=EMPTY_OBJ)}else if(raw){isObject(raw)||warn("invalid props options",raw);for(const key in raw){const normalizedKey=camelize(key);if(validatePropName(normalizedKey)){const opt=raw[key],prop=normalized[normalizedKey]=isArray(opt)||isFunction(opt)?{type:opt}:opt;if(prop){const booleanIndex=getTypeIndex(Boolean,prop.type),stringIndex=getTypeIndex(String,prop.type);prop[0]=booleanIndex>-1,prop[1]=stringIndex<0||booleanIndex<stringIndex,(booleanIndex>-1||hasOwn(prop,"default"))&&needCastKeys.push(normalizedKey)}}}}return cache[appId]=[normalized,needCastKeys]}function getType(ctor){const match=ctor&&ctor.toString().match(/^\s*function (\w+)/);return match?match[1]:""}function isSameType(a,b){return getType(a)===getType(b)}function getTypeIndex(type,expectedTypes){if(isArray(expectedTypes)){for(let i=0,len=expectedTypes.length;i<len;i++)if(isSameType(expectedTypes[i],type))return i}else if(isFunction(expectedTypes))return isSameType(expectedTypes,type)?0:-1;return-1}function validateProps(props,instance){const rawValues=toRaw(props),options=instance.propsOptions[0];for(const key in options){let opt=options[key];null!=opt&&validateProp(key,rawValues[key],opt,!hasOwn(rawValues,key))}}function validatePropName(key){return"$"!==key[0]||(warn(`Invalid prop name: "${key}" is a reserved property.`),!1)}function validateProp(name,value,prop,isAbsent){const{type:type,required:required,validator:validator}=prop;if(required&&isAbsent)warn('Missing required prop: "'+name+'"');else if(null!=value||prop.required){if(null!=type&&!0!==type){let isValid=!1;const types=isArray(type)?type:[type],expectedTypes=[];for(let i=0;i<types.length&&!isValid;i++){const{valid:valid,expectedType:expectedType}=assertType(value,types[i]);expectedTypes.push(expectedType||""),isValid=valid}if(!isValid)return void warn(getInvalidTypeMessage(name,value,expectedTypes))}validator&&!validator(value)&&warn('Invalid prop: custom validator check failed for prop "'+name+'".')}}const isSimpleType=makeMap("String,Number,Boolean,Function,Symbol");function assertType(value,type){let valid;const expectedType=getType(type);if(isSimpleType(expectedType)){const t=typeof value;valid=t===expectedType.toLowerCase(),valid||"object"!==t||(valid=value instanceof type)}else valid="Object"===expectedType?isObject(value):"Array"===expectedType?isArray(value):value instanceof type;return{valid:valid,expectedType:expectedType}}function getInvalidTypeMessage(name,value,expectedTypes){let message=`Invalid prop: type check failed for prop "${name}".`+` Expected ${expectedTypes.map(capitalize).join(", ")}`;const expectedType=expectedTypes[0],receivedType=toRawType(value),expectedValue=styleValue(value,expectedType),receivedValue=styleValue(value,receivedType);return 1===expectedTypes.length&&isExplicable(expectedType)&&!isBoolean(expectedType,receivedType)&&(message+=` with value ${expectedValue}`),message+=`, got ${receivedType} `,isExplicable(receivedType)&&(message+=`with value ${receivedValue}.`),message}function styleValue(value,type){return"String"===type?`"${value}"`:"Number"===type?`${Number(value)}`:`${value}`}function isExplicable(type){const explicitTypes=["string","number","boolean"];return explicitTypes.some(elem=>type.toLowerCase()===elem)}function isBoolean(...args){return args.some(elem=>"boolean"===elem.toLowerCase())}function injectHook(type,hook,target=currentInstance,prepend=!1){if(target){const hooks=target[type]||(target[type]=[]),wrappedHook=hook.__weh||(hook.__weh=(...args)=>{if(target.isUnmounted)return;pauseTracking(),setCurrentInstance(target);const res=callWithAsyncErrorHandling(hook,target,type,args);return setCurrentInstance(null),resetTracking(),res});return prepend?hooks.unshift(wrappedHook):hooks.push(wrappedHook),wrappedHook}{const apiName=`on${capitalize(ErrorTypeStrings[type].replace(/ hook$/,""))}`;warn(`${apiName} is called when there is no active component instance to be `+"associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.")}}const createHook=lifecycle=>(hook,target=currentInstance)=>!isInSSRComponentSetup&&injectHook(lifecycle,hook,target),onBeforeMount=createHook("bm"),onMounted=createHook("m"),onBeforeUpdate=createHook("bu"),onUpdated=createHook("u"),onBeforeUnmount=createHook("bum"),onUnmounted=createHook("um"),onRenderTriggered=createHook("rtg"),onRenderTracked=createHook("rtc"),onErrorCaptured=(hook,target=currentInstance)=>{injectHook("ec",hook,target)};function useTransitionState(){const state={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return onMounted(()=>{state.isMounted=!0}),onBeforeUnmount(()=>{state.isUnmounting=!0}),state}const TransitionHookValidator=[Function,Array],BaseTransitionImpl={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:TransitionHookValidator,onEnter:TransitionHookValidator,onAfterEnter:TransitionHookValidator,onEnterCancelled:TransitionHookValidator,onBeforeLeave:TransitionHookValidator,onLeave:TransitionHookValidator,onAfterLeave:TransitionHookValidator,onLeaveCancelled:TransitionHookValidator,onBeforeAppear:TransitionHookValidator,onAppear:TransitionHookValidator,onAfterAppear:TransitionHookValidator,onAppearCancelled:TransitionHookValidator},setup(props,{slots:slots}){const instance=getCurrentInstance(),state=useTransitionState();let prevTransitionKey;return()=>{const children=slots.default&&getTransitionRawChildren(slots.default(),!0);if(!children||!children.length)return;children.length>1&&warn("<transition> can only be used on a single element or component. Use <transition-group> for lists.");const rawProps=toRaw(props),{mode:mode}=rawProps;mode&&!["in-out","out-in","default"].includes(mode)&&warn(`invalid <transition> mode: ${mode}`);const child=children[0];if(state.isLeaving)return emptyPlaceholder(child);const innerChild=getKeepAliveChild(child);if(!innerChild)return emptyPlaceholder(child);const enterHooks=resolveTransitionHooks(innerChild,rawProps,state,instance);setTransitionHooks(innerChild,enterHooks);const oldChild=instance.subTree,oldInnerChild=oldChild&&getKeepAliveChild(oldChild);let transitionKeyChanged=!1;const{getTransitionKey:getTransitionKey}=innerChild.type;if(getTransitionKey){const key=getTransitionKey();void 0===prevTransitionKey?prevTransitionKey=key:key!==prevTransitionKey&&(prevTransitionKey=key,transitionKeyChanged=!0)}if(oldInnerChild&&oldInnerChild.type!==Comment&&(!isSameVNodeType(innerChild,oldInnerChild)||transitionKeyChanged)){const leavingHooks=resolveTransitionHooks(oldInnerChild,rawProps,state,instance);if(setTransitionHooks(oldInnerChild,leavingHooks),"out-in"===mode)return state.isLeaving=!0,leavingHooks.afterLeave=()=>{state.isLeaving=!1,instance.update()},emptyPlaceholder(child);"in-out"===mode&&(leavingHooks.delayLeave=(el,earlyRemove,delayedLeave)=>{const leavingVNodesCache=getLeavingNodesForType(state,oldInnerChild);leavingVNodesCache[String(oldInnerChild.key)]=oldInnerChild,el._leaveCb=()=>{earlyRemove(),el._leaveCb=void 0,delete enterHooks.delayedLeave},enterHooks.delayedLeave=delayedLeave})}return child}}},BaseTransition=BaseTransitionImpl;function getLeavingNodesForType(state,vnode){const{leavingVNodes:leavingVNodes}=state;let leavingVNodesCache=leavingVNodes.get(vnode.type);return leavingVNodesCache||(leavingVNodesCache=Object.create(null),leavingVNodes.set(vnode.type,leavingVNodesCache)),leavingVNodesCache}function resolveTransitionHooks(vnode,props,state,instance){const{appear:appear,mode:mode,persisted:persisted=!1,onBeforeEnter:onBeforeEnter,onEnter:onEnter,onAfterEnter:onAfterEnter,onEnterCancelled:onEnterCancelled,onBeforeLeave:onBeforeLeave,onLeave:onLeave,onAfterLeave:onAfterLeave,onLeaveCancelled:onLeaveCancelled,onBeforeAppear:onBeforeAppear,onAppear:onAppear,onAfterAppear:onAfterAppear,onAppearCancelled:onAppearCancelled}=props,key=String(vnode.key),leavingVNodesCache=getLeavingNodesForType(state,vnode),callHook=(hook,args)=>{hook&&callWithAsyncErrorHandling(hook,instance,9,args)},hooks={mode:mode,persisted:persisted,beforeEnter(el){let hook=onBeforeEnter;if(!state.isMounted){if(!appear)return;hook=onBeforeAppear||onBeforeEnter}el._leaveCb&&el._leaveCb(!0);const leavingVNode=leavingVNodesCache[key];leavingVNode&&isSameVNodeType(vnode,leavingVNode)&&leavingVNode.el._leaveCb&&leavingVNode.el._leaveCb(),callHook(hook,[el])},enter(el){let hook=onEnter,afterHook=onAfterEnter,cancelHook=onEnterCancelled;if(!state.isMounted){if(!appear)return;hook=onAppear||onEnter,afterHook=onAfterAppear||onAfterEnter,cancelHook=onAppearCancelled||onEnterCancelled}let called=!1;const done=el._enterCb=cancelled=>{called||(called=!0,callHook(cancelled?cancelHook:afterHook,[el]),hooks.delayedLeave&&hooks.delayedLeave(),el._enterCb=void 0)};hook?(hook(el,done),hook.length<=1&&done()):done()},leave(el,remove){const key=String(vnode.key);if(el._enterCb&&el._enterCb(!0),state.isUnmounting)return remove();callHook(onBeforeLeave,[el]);let called=!1;const done=el._leaveCb=cancelled=>{called||(called=!0,remove(),callHook(cancelled?onLeaveCancelled:onAfterLeave,[el]),el._leaveCb=void 0,leavingVNodesCache[key]===vnode&&delete leavingVNodesCache[key])};leavingVNodesCache[key]=vnode,onLeave?(onLeave(el,done),onLeave.length<=1&&done()):done()},clone:vnode=>resolveTransitionHooks(vnode,props,state,instance)};return hooks}function emptyPlaceholder(vnode){if(isKeepAlive(vnode))return(vnode=cloneVNode(vnode)).children=null,vnode}function getKeepAliveChild(vnode){return isKeepAlive(vnode)?vnode.children?vnode.children[0]:void 0:vnode}function setTransitionHooks(vnode,hooks){6&vnode.shapeFlag&&vnode.component?setTransitionHooks(vnode.component.subTree,hooks):128&vnode.shapeFlag?(vnode.ssContent.transition=hooks.clone(vnode.ssContent),vnode.ssFallback.transition=hooks.clone(vnode.ssFallback)):vnode.transition=hooks}function getTransitionRawChildren(children,keepComment=!1){let ret=[],keyedFragmentCount=0;for(let i=0;i<children.length;i++){const child=children[i];child.type===Fragment?(128&child.patchFlag&&keyedFragmentCount++,ret=ret.concat(getTransitionRawChildren(child.children,keepComment))):(keepComment||child.type!==Comment)&&ret.push(child)}if(keyedFragmentCount>1)for(let i=0;i<ret.length;i++)ret[i].patchFlag=-2;return ret}const isKeepAlive=vnode=>vnode.type.__isKeepAlive,KeepAliveImpl={name:"KeepAlive",__isKeepAlive:!0,inheritRef:!0,props:{include:[String,RegExp,Array],exclude:[String,RegExp,Array],max:[String,Number]},setup(props,{slots:slots}){const cache=new Map,keys=new Set;let current=null;const instance=getCurrentInstance(),parentSuspense=instance.suspense,sharedContext=instance.ctx,{renderer:{p:patch,m:move,um:_unmount,o:{createElement:createElement}}}=sharedContext,storageContainer=createElement("div");function unmount(vnode){resetShapeFlag(vnode),_unmount(vnode,instance,parentSuspense)}function pruneCache(filter){cache.forEach((vnode,key)=>{const name=getName(vnode.type);!name||filter&&filter(name)||pruneCacheEntry(key)})}function pruneCacheEntry(key){const cached=cache.get(key);current&&cached.type===current.type?current&&resetShapeFlag(current):unmount(cached),cache.delete(key),keys.delete(key)}sharedContext.activate=(vnode,container,anchor,isSVG,optimized)=>{const instance=vnode.component;move(vnode,container,anchor,0,parentSuspense),patch(instance.vnode,vnode,container,anchor,instance,parentSuspense,isSVG,optimized),queuePostRenderEffect(()=>{instance.isDeactivated=!1,instance.a&&invokeArrayFns(instance.a);const vnodeHook=vnode.props&&vnode.props.onVnodeMounted;vnodeHook&&invokeVNodeHook(vnodeHook,instance.parent,vnode)},parentSuspense)},sharedContext.deactivate=vnode=>{const instance=vnode.component;move(vnode,storageContainer,null,1,parentSuspense),queuePostRenderEffect(()=>{instance.da&&invokeArrayFns(instance.da);const vnodeHook=vnode.props&&vnode.props.onVnodeUnmounted;vnodeHook&&invokeVNodeHook(vnodeHook,instance.parent,vnode),instance.isDeactivated=!0},parentSuspense)},watch(()=>[props.include,props.exclude],([include,exclude])=>{include&&pruneCache(name=>matches(include,name)),exclude&&pruneCache(name=>!matches(exclude,name))},{flush:"post"});let pendingCacheKey=null;const cacheSubtree=()=>{null!=pendingCacheKey&&cache.set(pendingCacheKey,getInnerChild(instance.subTree))};return onMounted(cacheSubtree),onUpdated(cacheSubtree),onBeforeUnmount(()=>{cache.forEach(cached=>{const{subTree:subTree,suspense:suspense}=instance,vnode=getInnerChild(subTree);if(cached.type!==vnode.type)unmount(cached);else{resetShapeFlag(vnode);const da=vnode.component.da;da&&queuePostRenderEffect(da,suspense)}})}),()=>{if(pendingCacheKey=null,!slots.default)return null;const children=slots.default(),rawVNode=children[0];if(children.length>1)return warn("KeepAlive should contain exactly one component child."),current=null,children;if(!(isVNode(rawVNode)&&(4&rawVNode.shapeFlag||128&rawVNode.shapeFlag)))return current=null,rawVNode;let vnode=getInnerChild(rawVNode);const comp=vnode.type,name=getName(comp),{include:include,exclude:exclude,max:max}=props;if(include&&(!name||!matches(include,name))||exclude&&name&&matches(exclude,name))return current=vnode,rawVNode;const key=null==vnode.key?comp:vnode.key,cachedVNode=cache.get(key);return vnode.el&&(vnode=cloneVNode(vnode),128&rawVNode.shapeFlag&&(rawVNode.ssContent=vnode)),pendingCacheKey=key,cachedVNode?(vnode.el=cachedVNode.el,vnode.component=cachedVNode.component,vnode.transition&&setTransitionHooks(vnode,vnode.transition),vnode.shapeFlag|=512,keys.delete(key),keys.add(key)):(keys.add(key),max&&keys.size>parseInt(max,10)&&pruneCacheEntry(keys.values().next().value)),vnode.shapeFlag|=256,current=vnode,rawVNode}}},KeepAlive=KeepAliveImpl;function getName(comp){return comp.displayName||comp.name}function matches(pattern,name){return isArray(pattern)?pattern.some(p=>matches(p,name)):isString(pattern)?pattern.split(",").indexOf(name)>-1:!!pattern.test&&pattern.test(name)}function onActivated(hook,target){registerKeepAliveHook(hook,"a",target)}function onDeactivated(hook,target){registerKeepAliveHook(hook,"da",target)}function registerKeepAliveHook(hook,type,target=currentInstance){const wrappedHook=hook.__wdc||(hook.__wdc=()=>{let current=target;for(;current;){if(current.isDeactivated)return;current=current.parent}hook()});if(injectHook(type,wrappedHook,target),target){let current=target.parent;for(;current&&current.parent;)isKeepAlive(current.parent.vnode)&&injectToKeepAliveRoot(wrappedHook,type,target,current),current=current.parent}}function injectToKeepAliveRoot(hook,type,target,keepAliveRoot){const injected=injectHook(type,hook,keepAliveRoot,!0);onUnmounted(()=>{remove(keepAliveRoot[type],injected)},target)}function resetShapeFlag(vnode){let shapeFlag=vnode.shapeFlag;256&shapeFlag&&(shapeFlag-=256),512&shapeFlag&&(shapeFlag-=512),vnode.shapeFlag=shapeFlag}function getInnerChild(vnode){return 128&vnode.shapeFlag?vnode.ssContent:vnode}const isInternalKey=key=>"_"===key[0]||"$stable"===key,normalizeSlotValue=value=>isArray(value)?value.map(normalizeVNode):[normalizeVNode(value)],normalizeSlot=(key,rawSlot,ctx)=>withCtx(props=>(currentInstance&&warn(`Slot "${key}" invoked outside of the render function: `+"this will not track dependencies used in the slot. Invoke the slot function inside the render function instead."),normalizeSlotValue(rawSlot(props))),ctx),normalizeObjectSlots=(rawSlots,slots)=>{const ctx=rawSlots._ctx;for(const key in rawSlots){if(isInternalKey(key))continue;const value=rawSlots[key];if(isFunction(value))slots[key]=normalizeSlot(key,value,ctx);else if(null!=value){warn(`Non-function value encountered for slot "${key}". `+"Prefer function slots for better performance.");const normalized=normalizeSlotValue(value);slots[key]=()=>normalized}}},normalizeVNodeSlots=(instance,children)=>{isKeepAlive(instance.vnode)||warn("Non-function value encountered for default slot. Prefer function slots for better performance.");const normalized=normalizeSlotValue(children);instance.slots.default=()=>normalized},initSlots=(instance,children)=>{if(32&instance.vnode.shapeFlag){const type=children._;type?(instance.slots=children,def(children,"_",type)):normalizeObjectSlots(children,instance.slots={})}else instance.slots={},children&&normalizeVNodeSlots(instance,children);def(instance.slots,"__vInternal",1)},updateSlots=(instance,children)=>{const{vnode:vnode,slots:slots}=instance;let needDeletionCheck=!0,deletionComparisonTarget=EMPTY_OBJ;if(32&vnode.shapeFlag){const type=children._;type?isHmrUpdating?extend(slots,children):1===type?needDeletionCheck=!1:extend(slots,children):(needDeletionCheck=!children.$stable,normalizeObjectSlots(children,slots)),deletionComparisonTarget=children}else children&&(normalizeVNodeSlots(instance,children),deletionComparisonTarget={default:1});if(needDeletionCheck)for(const key in slots)isInternalKey(key)||key in deletionComparisonTarget||delete slots[key]},isBuiltInDirective=makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text");function validateDirectiveName(name){isBuiltInDirective(name)&&warn("Do not use built-in directive ids as custom directive id: "+name)}function withDirectives(vnode,directives){const internalInstance=currentRenderingInstance;if(null===internalInstance)return warn("withDirectives can only be used inside render functions."),vnode;const instance=internalInstance.proxy,bindings=vnode.dirs||(vnode.dirs=[]);for(let i=0;i<directives.length;i++){let[dir,value,arg,modifiers=EMPTY_OBJ]=directives[i];isFunction(dir)&&(dir={mounted:dir,updated:dir}),bindings.push({dir:dir,instance:instance,value:value,oldValue:void 0,arg:arg,modifiers:modifiers})}return vnode}function invokeDirectiveHook(vnode,prevVNode,instance,name){const bindings=vnode.dirs,oldBindings=prevVNode&&prevVNode.dirs;for(let i=0;i<bindings.length;i++){const binding=bindings[i];oldBindings&&(binding.oldValue=oldBindings[i].value);const hook=binding.dir[name];hook&&callWithAsyncErrorHandling(hook,instance,8,[vnode.el,binding,vnode,prevVNode])}}function createAppContext(){return{app:null,config:{isNativeTag:NO,performance:!1,globalProperties:{},optionMergeStrategies:{},isCustomElement:NO,errorHandler:void 0,warnHandler:void 0},mixins:[],components:{},directives:{},provides:Object.create(null)}}let uid$1=0;function createAppAPI(render,hydrate){return function createApp(rootComponent,rootProps=null){null==rootProps||isObject(rootProps)||(warn("root props passed to app.mount() must be an object."),rootProps=null);const context=createAppContext(),installedPlugins=new Set;let isMounted=!1;const app=context.app={_uid:uid$1++,_component:rootComponent,_props:rootProps,_container:null,_context:context,version:version,get config(){return context.config},set config(v){warn("app.config cannot be replaced. Modify individual options instead.")},use:(plugin,...options)=>(installedPlugins.has(plugin)?warn("Plugin has already been applied to target app."):plugin&&isFunction(plugin.install)?(installedPlugins.add(plugin),plugin.install(app,...options)):isFunction(plugin)?(installedPlugins.add(plugin),plugin(app,...options)):warn('A plugin must either be a function or an object with an "install" function.'),app),mixin:mixin=>(context.mixins.includes(mixin)?warn("Mixin has already been applied to target app"+(mixin.name?`: ${mixin.name}`:"")):context.mixins.push(mixin),app),component:(name,component)=>(validateComponentName(name,context.config),component?(context.components[name]&&warn(`Component "${name}" has already been registered in target app.`),context.components[name]=component,app):context.components[name]),directive:(name,directive)=>(validateDirectiveName(name),directive?(context.directives[name]&&warn(`Directive "${name}" has already been registered in target app.`),context.directives[name]=directive,app):context.directives[name]),mount(rootContainer,isHydrate){if(!isMounted){const vnode=createVNode(rootComponent,rootProps);return vnode.appContext=context,context.reload=()=>{render(cloneVNode(vnode),rootContainer)},isHydrate&&hydrate?hydrate(vnode,rootContainer):render(vnode,rootContainer),isMounted=!0,app._container=rootContainer,rootContainer.__vue_app__=app,devtoolsInitApp(app,version),vnode.component.proxy}warn("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`")},unmount(){isMounted?(render(null,app._container),devtoolsUnmountApp(app)):warn("Cannot unmount an app that is not mounted.")},provide:(key,value)=>(key in context.provides&&warn(`App already provides property with key "${String(key)}". `+"It will be overwritten with the new value."),context.provides[key]=value,app)};return app}}let hasMismatch=!1;const isSVGContainer=container=>/svg/.test(container.namespaceURI)&&"foreignObject"!==container.tagName,isComment=node=>8===node.nodeType;function createHydrationFunctions(rendererInternals){const{mt:mountComponent,p:patch,o:{patchProp:patchProp,nextSibling:nextSibling,parentNode:parentNode,remove:remove,insert:insert,createComment:createComment}}=rendererInternals,hydrate=(vnode,container)=>{if(!container.hasChildNodes())return warn("Attempting to hydrate existing markup but container is empty. Performing full mount instead."),void patch(null,vnode,container);hasMismatch=!1,hydrateNode(container.firstChild,vnode,null,null),flushPostFlushCbs(),hasMismatch&&console.error("Hydration completed but contains mismatches.")},hydrateNode=(node,vnode,parentComponent,parentSuspense,optimized=!1)=>{const isFragmentStart=isComment(node)&&"["===node.data,onMismatch=()=>handleMismatch(node,vnode,parentComponent,parentSuspense,isFragmentStart),{type:type,ref:ref,shapeFlag:shapeFlag}=vnode,domType=node.nodeType;vnode.el=node;let nextNode=null;switch(type){case Text:3!==domType?nextNode=onMismatch():(node.data!==vnode.children&&(hasMismatch=!0,warn("Hydration text mismatch:"+`\n- Client: ${JSON.stringify(node.data)}`+`\n- Server: ${JSON.stringify(vnode.children)}`),node.data=vnode.children),nextNode=nextSibling(node));break;case Comment:nextNode=8!==domType||isFragmentStart?onMismatch():nextSibling(node);break;case Static:if(1===domType){nextNode=node;const needToAdoptContent=!vnode.children.length;for(let i=0;i<vnode.staticCount;i++)needToAdoptContent&&(vnode.children+=nextNode.outerHTML),i===vnode.staticCount-1&&(vnode.anchor=nextNode),nextNode=nextSibling(nextNode);return nextNode}nextNode=onMismatch();break;case Fragment:nextNode=isFragmentStart?hydrateFragment(node,vnode,parentComponent,parentSuspense,optimized):onMismatch();break;default:if(1&shapeFlag)nextNode=1!==domType||vnode.type!==node.tagName.toLowerCase()?onMismatch():hydrateElement(node,vnode,parentComponent,parentSuspense,optimized);else if(6&shapeFlag){const container=parentNode(node),hydrateComponent=()=>{mountComponent(vnode,container,null,parentComponent,parentSuspense,isSVGContainer(container),optimized)},loadAsync=vnode.type.__asyncLoader;loadAsync?loadAsync().then(hydrateComponent):hydrateComponent(),nextNode=isFragmentStart?locateClosingAsyncAnchor(node):nextSibling(node)}else 64&shapeFlag?nextNode=8!==domType?onMismatch():vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,optimized,rendererInternals,hydrateChildren):128&shapeFlag?nextNode=vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,isSVGContainer(parentNode(node)),optimized,rendererInternals,hydrateNode):warn("Invalid HostVNode type:",type,`(${typeof type})`)}return null!=ref&&parentComponent&&setRef(ref,null,parentComponent,parentSuspense,vnode),nextNode},hydrateElement=(el,vnode,parentComponent,parentSuspense,optimized)=>{optimized=optimized||!!vnode.dynamicChildren;const{props:props,patchFlag:patchFlag,shapeFlag:shapeFlag,dirs:dirs}=vnode;if(-1!==patchFlag){if(dirs&&invokeDirectiveHook(vnode,null,parentComponent,"created"),props)if(!optimized||16&patchFlag||32&patchFlag)for(const key in props)!isReservedProp(key)&&isOn(key)&&patchProp(el,key,null,props[key]);else props.onClick&&patchProp(el,"onClick",null,props.onClick);let vnodeHooks;if((vnodeHooks=props&&props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHooks,parentComponent,vnode),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeMount"),((vnodeHooks=props&&props.onVnodeMounted)||dirs)&&queueEffectWithSuspense(()=>{vnodeHooks&&invokeVNodeHook(vnodeHooks,parentComponent,vnode),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"mounted")},parentSuspense),16&shapeFlag&&(!props||!props.innerHTML&&!props.textContent)){let next=hydrateChildren(el.firstChild,vnode,el,parentComponent,parentSuspense,optimized),hasWarned=!1;for(;next;){hasMismatch=!0,hasWarned||(warn(`Hydration children mismatch in <${vnode.type}>: `+"server rendered element contains more child nodes than client vdom."),hasWarned=!0);const cur=next;next=next.nextSibling,remove(cur)}}else 8&shapeFlag&&el.textContent!==vnode.children&&(hasMismatch=!0,warn(`Hydration text content mismatch in <${vnode.type}>:\n`+`- Client: ${el.textContent}\n`+`- Server: ${vnode.children}`),el.textContent=vnode.children)}return el.nextSibling},hydrateChildren=(node,parentVNode,container,parentComponent,parentSuspense,optimized)=>{optimized=optimized||!!parentVNode.dynamicChildren;const children=parentVNode.children,l=children.length;let hasWarned=!1;for(let i=0;i<l;i++){const vnode=optimized?children[i]:children[i]=normalizeVNode(children[i]);node?node=hydrateNode(node,vnode,parentComponent,parentSuspense,optimized):(hasMismatch=!0,hasWarned||(warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: `+"server rendered element contains fewer child nodes than client vdom."),hasWarned=!0),patch(null,vnode,container,null,parentComponent,parentSuspense,isSVGContainer(container)))}return node},hydrateFragment=(node,vnode,parentComponent,parentSuspense,optimized)=>{const container=parentNode(node),next=hydrateChildren(nextSibling(node),vnode,container,parentComponent,parentSuspense,optimized);return next&&isComment(next)&&"]"===next.data?nextSibling(vnode.anchor=next):(hasMismatch=!0,insert(vnode.anchor=createComment("]"),container,next),next)},handleMismatch=(node,vnode,parentComponent,parentSuspense,isFragment)=>{if(hasMismatch=!0,warn("Hydration node mismatch:\n- Client vnode:",vnode.type,"\n- Server rendered DOM:",node,3===node.nodeType?"(text)":isComment(node)&&"["===node.data?"(start of fragment)":""),vnode.el=null,isFragment){const end=locateClosingAsyncAnchor(node);for(;;){const next=nextSibling(node);if(!next||next===end)break;remove(next)}}const next=nextSibling(node),container=parentNode(node);return remove(node),patch(null,vnode,container,next,parentComponent,parentSuspense,isSVGContainer(container)),next},locateClosingAsyncAnchor=node=>{let match=0;for(;node;)if((node=nextSibling(node))&&isComment(node)&&("["===node.data&&match++,"]"===node.data)){if(0===match)return nextSibling(node);match--}return node};return[hydrate,hydrateNode]}let supported,perf;function startMeasure(instance,type){instance.appContext.config.performance&&isSupported()&&perf.mark(`vue-${type}-${instance.uid}`)}function endMeasure(instance,type){if(instance.appContext.config.performance&&isSupported()){const startTag=`vue-${type}-${instance.uid}`,endTag=startTag+":end";perf.mark(endTag),perf.measure(`<${formatComponentName(instance,instance.type)}> ${type}`,startTag,endTag),perf.clearMarks(startTag),perf.clearMarks(endTag)}}function isSupported(){return void 0!==supported?supported:("undefined"!=typeof window&&window.performance?(supported=!0,perf=window.performance):supported=!1,supported)}function createDevEffectOptions(instance){return{scheduler:queueJob,allowRecurse:!0,onTrack:instance.rtc?e=>invokeArrayFns(instance.rtc,e):void 0,onTrigger:instance.rtg?e=>invokeArrayFns(instance.rtg,e):void 0}}const queuePostRenderEffect=queueEffectWithSuspense,setRef=(rawRef,oldRawRef,parentComponent,parentSuspense,vnode)=>{if(isArray(rawRef))return void rawRef.forEach((r,i)=>setRef(r,oldRawRef&&(isArray(oldRawRef)?oldRawRef[i]:oldRawRef),parentComponent,parentSuspense,vnode));let value;value=vnode?4&vnode.shapeFlag?vnode.component.proxy:vnode.el:null;const{i:owner,r:ref}=rawRef;if(!owner)return void warn("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");const oldRef=oldRawRef&&oldRawRef.r,refs=owner.refs===EMPTY_OBJ?owner.refs={}:owner.refs,setupState=owner.setupState;if(null!=oldRef&&oldRef!==ref&&(isString(oldRef)?(refs[oldRef]=null,hasOwn(setupState,oldRef)&&(setupState[oldRef]=null)):isRef(oldRef)&&(oldRef.value=null)),isString(ref)){const doSet=()=>{refs[ref]=value,hasOwn(setupState,ref)&&(setupState[ref]=value)};value?(doSet.id=-1,queuePostRenderEffect(doSet,parentSuspense)):doSet()}else if(isRef(ref)){const doSet=()=>{ref.value=value};value?(doSet.id=-1,queuePostRenderEffect(doSet,parentSuspense)):doSet()}else isFunction(ref)?callWithErrorHandling(ref,parentComponent,12,[value,refs]):warn("Invalid template ref type:",value,`(${typeof value})`)};function createRenderer(options){return baseCreateRenderer(options)}function createHydrationRenderer(options){return baseCreateRenderer(options,createHydrationFunctions)}function baseCreateRenderer(options,createHydrationFns){const{insert:hostInsert,remove:hostRemove,patchProp:hostPatchProp,forcePatchProp:hostForcePatchProp,createElement:hostCreateElement,createText:hostCreateText,createComment:hostCreateComment,setText:hostSetText,setElementText:hostSetElementText,parentNode:hostParentNode,nextSibling:hostNextSibling,setScopeId:hostSetScopeId=NOOP,cloneNode:hostCloneNode,insertStaticContent:hostInsertStaticContent}=options,patch=(n1,n2,container,anchor=null,parentComponent=null,parentSuspense=null,isSVG=!1,optimized=!1)=>{n1&&!isSameVNodeType(n1,n2)&&(anchor=getNextHostNode(n1),unmount(n1,parentComponent,parentSuspense,!0),n1=null),-2===n2.patchFlag&&(optimized=!1,n2.dynamicChildren=null);const{type:type,ref:ref,shapeFlag:shapeFlag}=n2;switch(type){case Text:processText(n1,n2,container,anchor);break;case Comment:processCommentNode(n1,n2,container,anchor);break;case Static:null==n1?mountStaticNode(n2,container,anchor,isSVG):patchStaticNode(n1,n2,container,isSVG);break;case Fragment:processFragment(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized);break;default:1&shapeFlag?processElement(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized):6&shapeFlag?processComponent(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized):64&shapeFlag?type.process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized,internals):128&shapeFlag?type.process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized,internals):warn("Invalid VNode type:",type,`(${typeof type})`)}null!=ref&&parentComponent&&setRef(ref,n1&&n1.ref,parentComponent,parentSuspense,n2)},processText=(n1,n2,container,anchor)=>{if(null==n1)hostInsert(n2.el=hostCreateText(n2.children),container,anchor);else{const el=n2.el=n1.el;n2.children!==n1.children&&hostSetText(el,n2.children)}},processCommentNode=(n1,n2,container,anchor)=>{null==n1?hostInsert(n2.el=hostCreateComment(n2.children||""),container,anchor):n2.el=n1.el},mountStaticNode=(n2,container,anchor,isSVG)=>{[n2.el,n2.anchor]=hostInsertStaticContent(n2.children,container,anchor,isSVG)},patchStaticNode=(n1,n2,container,isSVG)=>{if(n2.children!==n1.children){const anchor=hostNextSibling(n1.anchor);removeStaticNode(n1),[n2.el,n2.anchor]=hostInsertStaticContent(n2.children,container,anchor,isSVG)}else n2.el=n1.el,n2.anchor=n1.anchor},moveStaticNode=(vnode,container,anchor)=>{let cur=vnode.el;const end=vnode.anchor;for(;cur&&cur!==end;){const next=hostNextSibling(cur);hostInsert(cur,container,anchor),cur=next}hostInsert(end,container,anchor)},removeStaticNode=vnode=>{let cur=vnode.el;for(;cur&&cur!==vnode.anchor;){const next=hostNextSibling(cur);hostRemove(cur),cur=next}hostRemove(vnode.anchor)},processElement=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized)=>{isSVG=isSVG||"svg"===n2.type,null==n1?mountElement(n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized):patchElement(n1,n2,parentComponent,parentSuspense,isSVG,optimized)},mountElement=(vnode,container,anchor,parentComponent,parentSuspense,isSVG,optimized)=>{let el,vnodeHook;const{type:type,props:props,shapeFlag:shapeFlag,transition:transition,scopeId:scopeId,patchFlag:patchFlag,dirs:dirs}=vnode;if(el=vnode.el=hostCreateElement(vnode.type,isSVG,props&&props.is),8&shapeFlag?hostSetElementText(el,vnode.children):16&shapeFlag&&mountChildren(vnode.children,el,null,parentComponent,parentSuspense,isSVG&&"foreignObject"!==type,optimized||!!vnode.dynamicChildren),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"created"),props){for(const key in props)isReservedProp(key)||hostPatchProp(el,key,null,props[key],isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren);(vnodeHook=props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHook,parentComponent,vnode)}setScopeId(el,scopeId,vnode,parentComponent),Object.defineProperty(el,"__vnode",{value:vnode,enumerable:!1}),Object.defineProperty(el,"__vueParentComponent",{value:parentComponent,enumerable:!1}),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeMount");const needCallTransitionHooks=(!parentSuspense||parentSuspense&&!parentSuspense.pendingBranch)&&transition&&!transition.persisted;needCallTransitionHooks&&transition.beforeEnter(el),hostInsert(el,container,anchor),((vnodeHook=props&&props.onVnodeMounted)||needCallTransitionHooks||dirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode),needCallTransitionHooks&&transition.enter(el),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"mounted")},parentSuspense)},setScopeId=(el,scopeId,vnode,parentComponent)=>{if(scopeId&&hostSetScopeId(el,scopeId),parentComponent){const treeOwnerId=parentComponent.type.__scopeId;treeOwnerId&&treeOwnerId!==scopeId&&hostSetScopeId(el,treeOwnerId+"-s");let subTree=parentComponent.subTree;subTree.type===Fragment&&(subTree=filterSingleRoot(subTree.children)||subTree),vnode===subTree&&setScopeId(el,parentComponent.vnode.scopeId,parentComponent.vnode,parentComponent.parent)}},mountChildren=(children,container,anchor,parentComponent,parentSuspense,isSVG,optimized,start=0)=>{for(let i=start;i<children.length;i++){const child=children[i]=optimized?cloneIfMounted(children[i]):normalizeVNode(children[i]);patch(null,child,container,anchor,parentComponent,parentSuspense,isSVG,optimized)}},patchElement=(n1,n2,parentComponent,parentSuspense,isSVG,optimized)=>{const el=n2.el=n1.el;let{patchFlag:patchFlag,dynamicChildren:dynamicChildren,dirs:dirs}=n2;patchFlag|=16&n1.patchFlag;const oldProps=n1.props||EMPTY_OBJ,newProps=n2.props||EMPTY_OBJ;let vnodeHook;if((vnodeHook=newProps.onVnodeBeforeUpdate)&&invokeVNodeHook(vnodeHook,parentComponent,n2,n1),dirs&&invokeDirectiveHook(n2,n1,parentComponent,"beforeUpdate"),isHmrUpdating&&(patchFlag=0,optimized=!1,dynamicChildren=null),patchFlag>0){if(16&patchFlag)patchProps(el,n2,oldProps,newProps,parentComponent,parentSuspense,isSVG);else if(2&patchFlag&&oldProps.class!==newProps.class&&hostPatchProp(el,"class",null,newProps.class,isSVG),4&patchFlag&&hostPatchProp(el,"style",oldProps.style,newProps.style,isSVG),8&patchFlag){const propsToUpdate=n2.dynamicProps;for(let i=0;i<propsToUpdate.length;i++){const key=propsToUpdate[i],prev=oldProps[key],next=newProps[key];(next!==prev||hostForcePatchProp&&hostForcePatchProp(el,key))&&hostPatchProp(el,key,prev,next,isSVG,n1.children,parentComponent,parentSuspense,unmountChildren)}}1&patchFlag&&n1.children!==n2.children&&hostSetElementText(el,n2.children)}else optimized||null!=dynamicChildren||patchProps(el,n2,oldProps,newProps,parentComponent,parentSuspense,isSVG);const areChildrenSVG=isSVG&&"foreignObject"!==n2.type;dynamicChildren?(patchBlockChildren(n1.dynamicChildren,dynamicChildren,el,parentComponent,parentSuspense,areChildrenSVG),parentComponent&&parentComponent.type.__hmrId&&traverseStaticChildren(n1,n2)):optimized||patchChildren(n1,n2,el,null,parentComponent,parentSuspense,areChildrenSVG),((vnodeHook=newProps.onVnodeUpdated)||dirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,n2,n1),dirs&&invokeDirectiveHook(n2,n1,parentComponent,"updated")},parentSuspense)},patchBlockChildren=(oldChildren,newChildren,fallbackContainer,parentComponent,parentSuspense,isSVG)=>{for(let i=0;i<newChildren.length;i++){const oldVNode=oldChildren[i],newVNode=newChildren[i],container=oldVNode.type===Fragment||!isSameVNodeType(oldVNode,newVNode)||6&oldVNode.shapeFlag||64&oldVNode.shapeFlag?hostParentNode(oldVNode.el):fallbackContainer;patch(oldVNode,newVNode,container,null,parentComponent,parentSuspense,isSVG,!0)}},patchProps=(el,vnode,oldProps,newProps,parentComponent,parentSuspense,isSVG)=>{if(oldProps!==newProps){for(const key in newProps){if(isReservedProp(key))continue;const next=newProps[key],prev=oldProps[key];(next!==prev||hostForcePatchProp&&hostForcePatchProp(el,key))&&hostPatchProp(el,key,prev,next,isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren)}if(oldProps!==EMPTY_OBJ)for(const key in oldProps)isReservedProp(key)||key in newProps||hostPatchProp(el,key,oldProps[key],null,isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren)}},processFragment=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized)=>{const fragmentStartAnchor=n2.el=n1?n1.el:hostCreateText(""),fragmentEndAnchor=n2.anchor=n1?n1.anchor:hostCreateText("");let{patchFlag:patchFlag,dynamicChildren:dynamicChildren}=n2;patchFlag>0&&(optimized=!0),isHmrUpdating&&(patchFlag=0,optimized=!1,dynamicChildren=null),null==n1?(hostInsert(fragmentStartAnchor,container,anchor),hostInsert(fragmentEndAnchor,container,anchor),mountChildren(n2.children,container,fragmentEndAnchor,parentComponent,parentSuspense,isSVG,optimized)):patchFlag>0&&64&patchFlag&&dynamicChildren?(patchBlockChildren(n1.dynamicChildren,dynamicChildren,container,parentComponent,parentSuspense,isSVG),parentComponent&&parentComponent.type.__hmrId?traverseStaticChildren(n1,n2):(null!=n2.key||parentComponent&&n2===parentComponent.subTree)&&traverseStaticChildren(n1,n2,!0)):patchChildren(n1,n2,container,fragmentEndAnchor,parentComponent,parentSuspense,isSVG,optimized)},processComponent=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized)=>{null==n1?512&n2.shapeFlag?parentComponent.ctx.activate(n2,container,anchor,isSVG,optimized):mountComponent(n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized):updateComponent(n1,n2,optimized)},mountComponent=(initialVNode,container,anchor,parentComponent,parentSuspense,isSVG,optimized)=>{const instance=initialVNode.component=createComponentInstance(initialVNode,parentComponent,parentSuspense);if(instance.type.__hmrId&&registerHMR(instance),pushWarningContext(initialVNode),startMeasure(instance,"mount"),isKeepAlive(initialVNode)&&(instance.ctx.renderer=internals),startMeasure(instance,"init"),setupComponent(instance),endMeasure(instance,"init"),instance.asyncDep){if(parentSuspense&&parentSuspense.registerDep(instance,setupRenderEffect),!initialVNode.el){const placeholder=instance.subTree=createVNode(Comment);processCommentNode(null,placeholder,container,anchor)}}else setupRenderEffect(instance,initialVNode,container,anchor,parentSuspense,isSVG,optimized),popWarningContext(),endMeasure(instance,"mount")},updateComponent=(n1,n2,optimized)=>{const instance=n2.component=n1.component;if(shouldUpdateComponent(n1,n2,optimized)){if(instance.asyncDep&&!instance.asyncResolved)return pushWarningContext(n2),updateComponentPreRender(instance,n2,optimized),void popWarningContext();instance.next=n2,invalidateJob(instance.update),instance.update()}else n2.component=n1.component,n2.el=n1.el,instance.vnode=n2},setupRenderEffect=(instance,initialVNode,container,anchor,parentSuspense,isSVG,optimized)=>{instance.update=effect((function componentEffect(){if(instance.isMounted){let{next:next,bu:bu,u:u,parent:parent,vnode:vnode}=instance,originNext=next,vnodeHook;pushWarningContext(next||instance.vnode),next?updateComponentPreRender(instance,next,optimized):next=vnode,next.el=vnode.el,bu&&invokeArrayFns(bu),(vnodeHook=next.props&&next.props.onVnodeBeforeUpdate)&&invokeVNodeHook(vnodeHook,parent,next,vnode),startMeasure(instance,"render");const nextTree=renderComponentRoot(instance);endMeasure(instance,"render");const prevTree=instance.subTree;instance.subTree=nextTree,instance.refs!==EMPTY_OBJ&&(instance.refs={}),startMeasure(instance,"patch"),patch(prevTree,nextTree,hostParentNode(prevTree.el),getNextHostNode(prevTree),instance,parentSuspense,isSVG),endMeasure(instance,"patch"),next.el=nextTree.el,null===originNext&&updateHOCHostEl(instance,nextTree.el),u&&queuePostRenderEffect(u,parentSuspense),(vnodeHook=next.props&&next.props.onVnodeUpdated)&&queuePostRenderEffect(()=>{invokeVNodeHook(vnodeHook,parent,next,vnode)},parentSuspense),devtoolsComponentUpdated(instance),popWarningContext()}else{let vnodeHook;const{el:el,props:props}=initialVNode,{bm:bm,m:m,parent:parent}=instance;bm&&invokeArrayFns(bm),(vnodeHook=props&&props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHook,parent,initialVNode),startMeasure(instance,"render");const subTree=instance.subTree=renderComponentRoot(instance);endMeasure(instance,"render"),el&&hydrateNode?(startMeasure(instance,"hydrate"),hydrateNode(initialVNode.el,subTree,instance,parentSuspense),endMeasure(instance,"hydrate")):(startMeasure(instance,"patch"),patch(null,subTree,container,anchor,instance,parentSuspense,isSVG),endMeasure(instance,"patch"),initialVNode.el=subTree.el),m&&queuePostRenderEffect(m,parentSuspense),(vnodeHook=props&&props.onVnodeMounted)&&queuePostRenderEffect(()=>{invokeVNodeHook(vnodeHook,parent,initialVNode)},parentSuspense);const{a:a}=instance;a&&256&initialVNode.shapeFlag&&queuePostRenderEffect(a,parentSuspense),instance.isMounted=!0}}),createDevEffectOptions(instance))},updateComponentPreRender=(instance,nextVNode,optimized)=>{nextVNode.component=instance;const prevProps=instance.vnode.props;instance.vnode=nextVNode,instance.next=null,updateProps(instance,nextVNode.props,prevProps,optimized),updateSlots(instance,nextVNode.children),flushPreFlushCbs(void 0,instance.update)},patchChildren=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized=!1)=>{const c1=n1&&n1.children,prevShapeFlag=n1?n1.shapeFlag:0,c2=n2.children,{patchFlag:patchFlag,shapeFlag:shapeFlag}=n2;if(patchFlag>0){if(128&patchFlag)return void patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,optimized);if(256&patchFlag)return void patchUnkeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,optimized)}8&shapeFlag?(16&prevShapeFlag&&unmountChildren(c1,parentComponent,parentSuspense),c2!==c1&&hostSetElementText(container,c2)):16&prevShapeFlag?16&shapeFlag?patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,optimized):unmountChildren(c1,parentComponent,parentSuspense,!0):(8&prevShapeFlag&&hostSetElementText(container,""),16&shapeFlag&&mountChildren(c2,container,anchor,parentComponent,parentSuspense,isSVG,optimized))},patchUnkeyedChildren=(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,optimized)=>{c2=c2||EMPTY_ARR;const oldLength=(c1=c1||EMPTY_ARR).length,newLength=c2.length,commonLength=Math.min(oldLength,newLength);let i;for(i=0;i<commonLength;i++){const nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);patch(c1[i],nextChild,container,null,parentComponent,parentSuspense,isSVG,optimized)}oldLength>newLength?unmountChildren(c1,parentComponent,parentSuspense,!0,commonLength):mountChildren(c2,container,anchor,parentComponent,parentSuspense,isSVG,optimized,commonLength)},patchKeyedChildren=(c1,c2,container,parentAnchor,parentComponent,parentSuspense,isSVG,optimized)=>{let i=0;const l2=c2.length;let e1=c1.length-1,e2=l2-1;for(;i<=e1&&i<=e2;){const n1=c1[i],n2=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);if(!isSameVNodeType(n1,n2))break;patch(n1,n2,container,null,parentComponent,parentSuspense,isSVG,optimized),i++}for(;i<=e1&&i<=e2;){const n1=c1[e1],n2=c2[e2]=optimized?cloneIfMounted(c2[e2]):normalizeVNode(c2[e2]);if(!isSameVNodeType(n1,n2))break;patch(n1,n2,container,null,parentComponent,parentSuspense,isSVG,optimized),e1--,e2--}if(i>e1){if(i<=e2){const nextPos=e2+1,anchor=nextPos<l2?c2[nextPos].el:parentAnchor;for(;i<=e2;)patch(null,c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]),container,anchor,parentComponent,parentSuspense,isSVG),i++}}else if(i>e2)for(;i<=e1;)unmount(c1[i],parentComponent,parentSuspense,!0),i++;else{const s1=i,s2=i,keyToNewIndexMap=new Map;for(i=s2;i<=e2;i++){const nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);null!=nextChild.key&&(keyToNewIndexMap.has(nextChild.key)&&warn("Duplicate keys found during update:",JSON.stringify(nextChild.key),"Make sure keys are unique."),keyToNewIndexMap.set(nextChild.key,i))}let j,patched=0;const toBePatched=e2-s2+1;let moved=!1,maxNewIndexSoFar=0;const newIndexToOldIndexMap=new Array(toBePatched);for(i=0;i<toBePatched;i++)newIndexToOldIndexMap[i]=0;for(i=s1;i<=e1;i++){const prevChild=c1[i];if(patched>=toBePatched){unmount(prevChild,parentComponent,parentSuspense,!0);continue}let newIndex;if(null!=prevChild.key)newIndex=keyToNewIndexMap.get(prevChild.key);else for(j=s2;j<=e2;j++)if(0===newIndexToOldIndexMap[j-s2]&&isSameVNodeType(prevChild,c2[j])){newIndex=j;break}void 0===newIndex?unmount(prevChild,parentComponent,parentSuspense,!0):(newIndexToOldIndexMap[newIndex-s2]=i+1,newIndex>=maxNewIndexSoFar?maxNewIndexSoFar=newIndex:moved=!0,patch(prevChild,c2[newIndex],container,null,parentComponent,parentSuspense,isSVG,optimized),patched++)}const increasingNewIndexSequence=moved?getSequence(newIndexToOldIndexMap):EMPTY_ARR;for(j=increasingNewIndexSequence.length-1,i=toBePatched-1;i>=0;i--){const nextIndex=s2+i,nextChild=c2[nextIndex],anchor=nextIndex+1<l2?c2[nextIndex+1].el:parentAnchor;0===newIndexToOldIndexMap[i]?patch(null,nextChild,container,anchor,parentComponent,parentSuspense,isSVG):moved&&(j<0||i!==increasingNewIndexSequence[j]?move(nextChild,container,anchor,2):j--)}}},move=(vnode,container,anchor,moveType,parentSuspense=null)=>{const{el:el,type:type,transition:transition,children:children,shapeFlag:shapeFlag}=vnode;if(6&shapeFlag)return void move(vnode.component.subTree,container,anchor,moveType);if(128&shapeFlag)return void vnode.suspense.move(container,anchor,moveType);if(64&shapeFlag)return void type.move(vnode,container,anchor,internals);if(type===Fragment){hostInsert(el,container,anchor);for(let i=0;i<children.length;i++)move(children[i],container,anchor,moveType);return void hostInsert(vnode.anchor,container,anchor)}if(type===Static)return void moveStaticNode(vnode,container,anchor);const needTransition=2!==moveType&&1&shapeFlag&&transition;if(needTransition)if(0===moveType)transition.beforeEnter(el),hostInsert(el,container,anchor),queuePostRenderEffect(()=>transition.enter(el),parentSuspense);else{const{leave:leave,delayLeave:delayLeave,afterLeave:afterLeave}=transition,remove=()=>hostInsert(el,container,anchor),performLeave=()=>{leave(el,()=>{remove(),afterLeave&&afterLeave()})};delayLeave?delayLeave(el,remove,performLeave):performLeave()}else hostInsert(el,container,anchor)},unmount=(vnode,parentComponent,parentSuspense,doRemove=!1)=>{const{type:type,props:props,ref:ref,children:children,dynamicChildren:dynamicChildren,shapeFlag:shapeFlag,patchFlag:patchFlag,dirs:dirs}=vnode;if(null!=ref&&parentComponent&&setRef(ref,null,parentComponent,parentSuspense,null),256&shapeFlag)return void parentComponent.ctx.deactivate(vnode);const shouldInvokeDirs=1&shapeFlag&&dirs;let vnodeHook;if((vnodeHook=props&&props.onVnodeBeforeUnmount)&&invokeVNodeHook(vnodeHook,parentComponent,vnode),6&shapeFlag)unmountComponent(vnode.component,parentSuspense,doRemove);else{if(128&shapeFlag)return void vnode.suspense.unmount(parentSuspense,doRemove);shouldInvokeDirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeUnmount"),dynamicChildren&&(type!==Fragment||patchFlag>0&&64&patchFlag)?unmountChildren(dynamicChildren,parentComponent,parentSuspense):16&shapeFlag&&unmountChildren(children,parentComponent,parentSuspense),64&shapeFlag&&vnode.type.remove(vnode,internals),doRemove&&remove(vnode)}((vnodeHook=props&&props.onVnodeUnmounted)||shouldInvokeDirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode),shouldInvokeDirs&&invokeDirectiveHook(vnode,null,parentComponent,"unmounted")},parentSuspense)},remove=vnode=>{const{type:type,el:el,anchor:anchor,transition:transition}=vnode;if(type===Fragment)return void removeFragment(el,anchor);if(type===Static)return void removeStaticNode(vnode);const performRemove=()=>{hostRemove(el),transition&&!transition.persisted&&transition.afterLeave&&transition.afterLeave()};if(1&vnode.shapeFlag&&transition&&!transition.persisted){const{leave:leave,delayLeave:delayLeave}=transition,performLeave=()=>leave(el,performRemove);delayLeave?delayLeave(vnode.el,performRemove,performLeave):performLeave()}else performRemove()},removeFragment=(cur,end)=>{let next;for(;cur!==end;)next=hostNextSibling(cur),hostRemove(cur),cur=next;hostRemove(end)},unmountComponent=(instance,parentSuspense,doRemove)=>{instance.type.__hmrId&&unregisterHMR(instance);const{bum:bum,effects:effects,update:update,subTree:subTree,um:um}=instance;if(bum&&invokeArrayFns(bum),effects)for(let i=0;i<effects.length;i++)stop(effects[i]);update&&(stop(update),unmount(subTree,instance,parentSuspense,doRemove)),um&&queuePostRenderEffect(um,parentSuspense),queuePostRenderEffect(()=>{instance.isUnmounted=!0},parentSuspense),parentSuspense&&parentSuspense.pendingBranch&&!parentSuspense.isUnmounted&&instance.asyncDep&&!instance.asyncResolved&&instance.suspenseId===parentSuspense.pendingId&&(parentSuspense.deps--,0===parentSuspense.deps&&parentSuspense.resolve()),devtoolsComponentRemoved(instance)},unmountChildren=(children,parentComponent,parentSuspense,doRemove=!1,start=0)=>{for(let i=start;i<children.length;i++)unmount(children[i],parentComponent,parentSuspense,doRemove)},getNextHostNode=vnode=>6&vnode.shapeFlag?getNextHostNode(vnode.component.subTree):128&vnode.shapeFlag?vnode.suspense.next():hostNextSibling(vnode.anchor||vnode.el),traverseStaticChildren=(n1,n2,shallow=!1)=>{const ch1=n1.children,ch2=n2.children;if(isArray(ch1)&&isArray(ch2))for(let i=0;i<ch1.length;i++){const c1=ch1[i],c2=ch2[i]=cloneIfMounted(ch2[i]);1&c2.shapeFlag&&!c2.dynamicChildren&&((c2.patchFlag<=0||32===c2.patchFlag)&&(c2.el=c1.el),shallow||traverseStaticChildren(c1,c2)),c2.type===Comment&&(c2.el=c1.el)}},render=(vnode,container)=>{null==vnode?container._vnode&&unmount(container._vnode,null,null,!0):patch(container._vnode||null,vnode,container),flushPostFlushCbs(),container._vnode=vnode},internals={p:patch,um:unmount,m:move,r:remove,mt:mountComponent,mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,n:getNextHostNode,o:options};let hydrate,hydrateNode;return createHydrationFns&&([hydrate,hydrateNode]=createHydrationFns(internals)),{render:render,hydrate:hydrate,createApp:createAppAPI(render,hydrate)}}function invokeVNodeHook(hook,instance,vnode,prevVNode=null){callWithAsyncErrorHandling(hook,instance,7,[vnode,prevVNode])}function getSequence(arr){const p=arr.slice(),result=[0];let i,j,u,v,c;const len=arr.length;for(i=0;i<len;i++){const arrI=arr[i];if(0!==arrI){if(j=result[result.length-1],arr[j]<arrI){p[i]=j,result.push(i);continue}for(u=0,v=result.length-1;u<v;)c=(u+v)/2|0,arr[result[c]]<arrI?u=c+1:v=c;arrI<arr[result[u]]&&(u>0&&(p[i]=result[u-1]),result[u]=i)}}for(u=result.length,v=result[u-1];u-- >0;)result[u]=v,v=p[v];return result}function watchEffect(effect,options){return doWatch(effect,null,options)}const INITIAL_WATCHER_VALUE={};function watch(source,cb,options){return isFunction(cb)||warn("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."),doWatch(source,cb,options)}function doWatch(source,cb,{immediate:immediate,deep:deep,flush:flush,onTrack:onTrack,onTrigger:onTrigger}=EMPTY_OBJ,instance=currentInstance){cb||(void 0!==immediate&&warn('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'),void 0!==deep&&warn('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));const warnInvalidSource=s=>{warn("Invalid watch source: ",s,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")};let getter;const isRefSource=isRef(source);if(isRefSource?getter=()=>source.value:isReactive(source)?(getter=()=>source,deep=!0):isArray(source)?getter=()=>source.map(s=>isRef(s)?s.value:isReactive(s)?traverse(s):isFunction(s)?callWithErrorHandling(s,instance,2):void warnInvalidSource(s)):isFunction(source)?getter=cb?()=>callWithErrorHandling(source,instance,2):()=>{if(!instance||!instance.isUnmounted)return cleanup&&cleanup(),callWithErrorHandling(source,instance,3,[onInvalidate])}:(getter=NOOP,warnInvalidSource(source)),cb&&deep){const baseGetter=getter;getter=()=>traverse(baseGetter())}let cleanup;const onInvalidate=fn=>{cleanup=runner.options.onStop=()=>{callWithErrorHandling(fn,instance,4)}};let oldValue=isArray(source)?[]:INITIAL_WATCHER_VALUE;const job=()=>{if(runner.active)if(cb){const newValue=runner();(deep||isRefSource||hasChanged(newValue,oldValue))&&(cleanup&&cleanup(),callWithAsyncErrorHandling(cb,instance,3,[newValue,oldValue===INITIAL_WATCHER_VALUE?void 0:oldValue,onInvalidate]),oldValue=newValue)}else runner()};let scheduler;job.allowRecurse=!!cb,scheduler="sync"===flush?job:"post"===flush?()=>queuePostRenderEffect(job,instance&&instance.suspense):()=>{!instance||instance.isMounted?queuePreFlushCb(job):job()};const runner=effect(getter,{lazy:!0,onTrack:onTrack,onTrigger:onTrigger,scheduler:scheduler});return recordInstanceBoundEffect(runner),cb?immediate?job():oldValue=runner():"post"===flush?queuePostRenderEffect(runner,instance&&instance.suspense):runner(),()=>{stop(runner),instance&&remove(instance.effects,runner)}}function instanceWatch(source,cb,options){const publicThis=this.proxy,getter=isString(source)?()=>publicThis[source]:source.bind(publicThis);return doWatch(getter,cb.bind(publicThis),options,this)}function traverse(value,seen=new Set){if(!isObject(value)||seen.has(value))return value;if(seen.add(value),isRef(value))traverse(value.value,seen);else if(isArray(value))for(let i=0;i<value.length;i++)traverse(value[i],seen);else if(isMap(value))value.forEach((_,key)=>{traverse(value.get(key),seen)});else if(isSet(value))value.forEach(v=>{traverse(v,seen)});else for(const key in value)traverse(value[key],seen);return value}function provide(key,value){if(currentInstance){let provides=currentInstance.provides;const parentProvides=currentInstance.parent&&currentInstance.parent.provides;parentProvides===provides&&(provides=currentInstance.provides=Object.create(parentProvides)),provides[key]=value}else warn("provide() can only be used inside setup().")}function inject(key,defaultValue,treatDefaultAsFactory=!1){const instance=currentInstance||currentRenderingInstance;if(instance){const provides=instance.provides;if(key in provides)return provides[key];if(arguments.length>1)return treatDefaultAsFactory&&isFunction(defaultValue)?defaultValue():defaultValue;warn(`injection "${String(key)}" not found.`)}else warn("inject() can only be used inside setup() or functional components.")}function createDuplicateChecker(){const cache=Object.create(null);return(type,key)=>{cache[key]?warn(`${type} property "${key}" is already defined in ${cache[key]}.`):cache[key]=type}}let isInBeforeCreate=!1;function applyOptions(instance,options,deferredData=[],deferredWatch=[],asMixin=!1){const{mixins:mixins,extends:extendsOptions,data:dataOptions,computed:computedOptions,methods:methods,watch:watchOptions,provide:provideOptions,inject:injectOptions,components:components,directives:directives,beforeMount:beforeMount,mounted:mounted,beforeUpdate:beforeUpdate,updated:updated,activated:activated,deactivated:deactivated,beforeDestroy:beforeDestroy,beforeUnmount:beforeUnmount,destroyed:destroyed,unmounted:unmounted,render:render,renderTracked:renderTracked,renderTriggered:renderTriggered,errorCaptured:errorCaptured}=options,publicThis=instance.proxy,ctx=instance.ctx,globalMixins=instance.appContext.mixins;asMixin&&render&&instance.render===NOOP&&(instance.render=render),asMixin||(isInBeforeCreate=!0,callSyncHook("beforeCreate",options,publicThis,globalMixins),isInBeforeCreate=!1,applyMixins(instance,globalMixins,deferredData,deferredWatch)),extendsOptions&&applyOptions(instance,extendsOptions,deferredData,deferredWatch,!0),mixins&&applyMixins(instance,mixins,deferredData,deferredWatch);const checkDuplicateProperties=createDuplicateChecker();{const[propsOptions]=instance.propsOptions;if(propsOptions)for(const key in propsOptions)checkDuplicateProperties("Props",key)}if(injectOptions)if(isArray(injectOptions))for(let i=0;i<injectOptions.length;i++){const key=injectOptions[i];ctx[key]=inject(key),checkDuplicateProperties("Inject",key)}else for(const key in injectOptions){const opt=injectOptions[key];isObject(opt)?ctx[key]=inject(opt.from||key,opt.default,!0):ctx[key]=inject(opt),checkDuplicateProperties("Inject",key)}if(methods)for(const key in methods){const methodHandler=methods[key];isFunction(methodHandler)?(ctx[key]=methodHandler.bind(publicThis),checkDuplicateProperties("Methods",key)):warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. `+"Did you reference the function correctly?")}if(asMixin)dataOptions&&deferredData.push(dataOptions);else{deferredData.length&&deferredData.forEach(dataFn=>resolveData(instance,dataFn,publicThis)),dataOptions&&resolveData(instance,dataOptions,publicThis);{const rawData=toRaw(instance.data);for(const key in rawData)checkDuplicateProperties("Data",key),"$"!==key[0]&&"_"!==key[0]&&Object.defineProperty(ctx,key,{configurable:!0,enumerable:!0,get:()=>rawData[key],set:NOOP})}}if(computedOptions)for(const key in computedOptions){const opt=computedOptions[key],get=isFunction(opt)?opt.bind(publicThis,publicThis):isFunction(opt.get)?opt.get.bind(publicThis,publicThis):NOOP;get===NOOP&&warn(`Computed property "${key}" has no getter.`);const set=!isFunction(opt)&&isFunction(opt.set)?opt.set.bind(publicThis):()=>{warn(`Write operation failed: computed property "${key}" is readonly.`)},c=computed$1({get:get,set:set});Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:()=>c.value,set:v=>c.value=v}),checkDuplicateProperties("Computed",key)}if(watchOptions&&deferredWatch.push(watchOptions),!asMixin&&deferredWatch.length&&deferredWatch.forEach(watchOptions=>{for(const key in watchOptions)createWatcher(watchOptions[key],ctx,publicThis,key)}),provideOptions){const provides=isFunction(provideOptions)?provideOptions.call(publicThis):provideOptions;for(const key in provides)provide(key,provides[key])}asMixin&&(components&&extend(instance.components||(instance.components=extend({},instance.type.components)),components),directives&&extend(instance.directives||(instance.directives=extend({},instance.type.directives)),directives)),asMixin||callSyncHook("created",options,publicThis,globalMixins),beforeMount&&onBeforeMount(beforeMount.bind(publicThis)),mounted&&onMounted(mounted.bind(publicThis)),beforeUpdate&&onBeforeUpdate(beforeUpdate.bind(publicThis)),updated&&onUpdated(updated.bind(publicThis)),activated&&onActivated(activated.bind(publicThis)),deactivated&&onDeactivated(deactivated.bind(publicThis)),errorCaptured&&onErrorCaptured(errorCaptured.bind(publicThis)),renderTracked&&onRenderTracked(renderTracked.bind(publicThis)),renderTriggered&&onRenderTriggered(renderTriggered.bind(publicThis)),beforeDestroy&&warn("`beforeDestroy` has been renamed to `beforeUnmount`."),beforeUnmount&&onBeforeUnmount(beforeUnmount.bind(publicThis)),destroyed&&warn("`destroyed` has been renamed to `unmounted`."),unmounted&&onUnmounted(unmounted.bind(publicThis))}function callSyncHook(name,options,ctx,globalMixins){callHookFromMixins(name,globalMixins,ctx);const{extends:base,mixins:mixins}=options;base&&callHookFromExtends(name,base,ctx),mixins&&callHookFromMixins(name,mixins,ctx);const selfHook=options[name];selfHook&&selfHook.call(ctx)}function callHookFromExtends(name,base,ctx){base.extends&&callHookFromExtends(name,base.extends,ctx);const baseHook=base[name];baseHook&&baseHook.call(ctx)}function callHookFromMixins(name,mixins,ctx){for(let i=0;i<mixins.length;i++){const chainedMixins=mixins[i].mixins;chainedMixins&&callHookFromMixins(name,chainedMixins,ctx);const fn=mixins[i][name];fn&&fn.call(ctx)}}function applyMixins(instance,mixins,deferredData,deferredWatch){for(let i=0;i<mixins.length;i++)applyOptions(instance,mixins[i],deferredData,deferredWatch,!0)}function resolveData(instance,dataFn,publicThis){isFunction(dataFn)||warn("The data option must be a function. Plain object usage is no longer supported.");const data=dataFn.call(publicThis,publicThis);isPromise(data)&&warn("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."),isObject(data)?instance.data===EMPTY_OBJ?instance.data=reactive(data):extend(instance.data,data):warn("data() should return an object.")}function createWatcher(raw,ctx,publicThis,key){const getter=key.includes(".")?createPathGetter(publicThis,key):()=>publicThis[key];if(isString(raw)){const handler=ctx[raw];isFunction(handler)?watch(getter,handler):warn(`Invalid watch handler specified by key "${raw}"`,handler)}else if(isFunction(raw))watch(getter,raw.bind(publicThis));else if(isObject(raw))if(isArray(raw))raw.forEach(r=>createWatcher(r,ctx,publicThis,key));else{const handler=isFunction(raw.handler)?raw.handler.bind(publicThis):ctx[raw.handler];isFunction(handler)?watch(getter,handler,raw):warn(`Invalid watch handler specified by key "${raw.handler}"`,handler)}else warn(`Invalid watch option: "${key}"`,raw)}function createPathGetter(ctx,path){const segments=path.split(".");return()=>{let cur=ctx;for(let i=0;i<segments.length&&cur;i++)cur=cur[segments[i]];return cur}}function resolveMergedOptions(instance){const raw=instance.type,{__merged:__merged,mixins:mixins,extends:extendsOptions}=raw;if(__merged)return __merged;const globalMixins=instance.appContext.mixins;if(!globalMixins.length&&!mixins&&!extendsOptions)return raw;const options={};return globalMixins.forEach(m=>mergeOptions(options,m,instance)),mergeOptions(options,raw,instance),raw.__merged=options}function mergeOptions(to,from,instance){const strats=instance.appContext.config.optionMergeStrategies,{mixins:mixins,extends:extendsOptions}=from;extendsOptions&&mergeOptions(to,extendsOptions,instance),mixins&&mixins.forEach(m=>mergeOptions(to,m,instance));for(const key in from)strats&&hasOwn(strats,key)?to[key]=strats[key](to[key],from[key],instance.proxy,key):to[key]=from[key]}const publicPropertiesMap=extend(Object.create(null),{$:i=>i,$el:i=>i.vnode.el,$data:i=>i.data,$props:i=>shallowReadonly(i.props),$attrs:i=>shallowReadonly(i.attrs),$slots:i=>shallowReadonly(i.slots),$refs:i=>shallowReadonly(i.refs),$parent:i=>i.parent&&i.parent.proxy,$root:i=>i.root&&i.root.proxy,$emit:i=>i.emit,$options:i=>resolveMergedOptions(i),$forceUpdate:i=>()=>queueJob(i.update),$nextTick:()=>nextTick,$watch:i=>instanceWatch.bind(i)}),PublicInstanceProxyHandlers={get({_:instance},key){const{ctx:ctx,setupState:setupState,data:data,props:props,accessCache:accessCache,type:type,appContext:appContext}=instance;if("__v_skip"===key)return!0;let normalizedProps;if("$"!==key[0]){const n=accessCache[key];if(void 0!==n)switch(n){case 0:return setupState[key];case 1:return data[key];case 3:return ctx[key];case 2:return props[key]}else{if(setupState!==EMPTY_OBJ&&hasOwn(setupState,key))return accessCache[key]=0,setupState[key];if(data!==EMPTY_OBJ&&hasOwn(data,key))return accessCache[key]=1,data[key];if((normalizedProps=instance.propsOptions[0])&&hasOwn(normalizedProps,key))return accessCache[key]=2,props[key];if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key))return accessCache[key]=3,ctx[key];isInBeforeCreate||(accessCache[key]=4)}}const publicGetter=publicPropertiesMap[key];let cssModule,globalProperties;return publicGetter?("$attrs"===key&&(track(instance,"get",key),markAttrsAccessed()),publicGetter(instance)):(cssModule=type.__cssModules)&&(cssModule=cssModule[key])?cssModule:ctx!==EMPTY_OBJ&&hasOwn(ctx,key)?(accessCache[key]=3,ctx[key]):(globalProperties=appContext.config.globalProperties,hasOwn(globalProperties,key)?globalProperties[key]:void(!currentRenderingInstance||isString(key)&&0===key.indexOf("__v")||(data===EMPTY_OBJ||"$"!==key[0]&&"_"!==key[0]||!hasOwn(data,key)?warn(`Property ${JSON.stringify(key)} was accessed during render `+"but is not defined on instance."):warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved `+'character ("$" or "_") and is not proxied on the render context.'))))},set({_:instance},key,value){const{data:data,setupState:setupState,ctx:ctx}=instance;if(setupState!==EMPTY_OBJ&&hasOwn(setupState,key))setupState[key]=value;else if(data!==EMPTY_OBJ&&hasOwn(data,key))data[key]=value;else if(key in instance.props)return warn(`Attempting to mutate prop "${key}". Props are readonly.`,instance),!1;return"$"===key[0]&&key.slice(1)in instance?(warn(`Attempting to mutate public property "${key}". `+"Properties starting with $ are reserved and readonly.",instance),!1):(key in instance.appContext.config.globalProperties?Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,value:value}):ctx[key]=value,!0)},has({_:{data:data,setupState:setupState,accessCache:accessCache,ctx:ctx,appContext:appContext,propsOptions:propsOptions}},key){let normalizedProps;return void 0!==accessCache[key]||data!==EMPTY_OBJ&&hasOwn(data,key)||setupState!==EMPTY_OBJ&&hasOwn(setupState,key)||(normalizedProps=propsOptions[0])&&hasOwn(normalizedProps,key)||hasOwn(ctx,key)||hasOwn(publicPropertiesMap,key)||hasOwn(appContext.config.globalProperties,key)},ownKeys:target=>(warn("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."),Reflect.ownKeys(target))},RuntimeCompiledPublicInstanceProxyHandlers=extend({},PublicInstanceProxyHandlers,{get(target,key){if(key!==Symbol.unscopables)return PublicInstanceProxyHandlers.get(target,key,target)},has(_,key){const has="_"!==key[0]&&!isGloballyWhitelisted(key);return!has&&PublicInstanceProxyHandlers.has(_,key)&&warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`),has}});function createRenderContext(instance){const target={};Object.defineProperty(target,"_",{configurable:!0,enumerable:!1,get:()=>instance}),Object.keys(publicPropertiesMap).forEach(key=>{Object.defineProperty(target,key,{configurable:!0,enumerable:!1,get:()=>publicPropertiesMap[key](instance),set:NOOP})});const{globalProperties:globalProperties}=instance.appContext.config;return Object.keys(globalProperties).forEach(key=>{Object.defineProperty(target,key,{configurable:!0,enumerable:!1,get:()=>globalProperties[key],set:NOOP})}),target}function exposePropsOnRenderContext(instance){const{ctx:ctx,propsOptions:[propsOptions]}=instance;propsOptions&&Object.keys(propsOptions).forEach(key=>{Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:()=>instance.props[key],set:NOOP})})}function exposeSetupStateOnRenderContext(instance){const{ctx:ctx,setupState:setupState}=instance;Object.keys(toRaw(setupState)).forEach(key=>{"$"!==key[0]&&"_"!==key[0]?Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:()=>setupState[key],set:NOOP}):warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" `+"which are reserved prefixes for Vue internals.")})}const emptyAppContext=createAppContext();let uid$2=0;function createComponentInstance(vnode,parent,suspense){const type=vnode.type,appContext=(parent?parent.appContext:vnode.appContext)||emptyAppContext,instance={uid:uid$2++,vnode:vnode,type:type,parent:parent,appContext:appContext,root:null,next:null,subTree:null,update:null,render:null,proxy:null,withProxy:null,effects:null,provides:parent?parent.provides:Object.create(appContext.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:normalizePropsOptions(type,appContext),emitsOptions:normalizeEmitsOptions(type,appContext),emit:null,emitted:null,ctx:EMPTY_OBJ,data:EMPTY_OBJ,props:EMPTY_OBJ,attrs:EMPTY_OBJ,slots:EMPTY_OBJ,refs:EMPTY_OBJ,setupState:EMPTY_OBJ,setupContext:null,suspense:suspense,suspenseId:suspense?suspense.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null};return instance.ctx=createRenderContext(instance),instance.root=parent?parent.root:instance,instance.emit=emit.bind(null,instance),devtoolsComponentAdded(instance),instance}let currentInstance=null;const getCurrentInstance=()=>currentInstance||currentRenderingInstance,setCurrentInstance=instance=>{currentInstance=instance},isBuiltInTag=makeMap("slot,component");function validateComponentName(name,config){const appIsNativeTag=config.isNativeTag||NO;(isBuiltInTag(name)||appIsNativeTag(name))&&warn("Do not use built-in or reserved HTML elements as component id: "+name)}let isInSSRComponentSetup=!1,compile;function setupComponent(instance,isSSR=!1){isInSSRComponentSetup=isSSR;const{props:props,children:children,shapeFlag:shapeFlag}=instance.vnode,isStateful=4&shapeFlag;initProps(instance,props,isStateful,isSSR),initSlots(instance,children);const setupResult=isStateful?setupStatefulComponent(instance,isSSR):void 0;return isInSSRComponentSetup=!1,setupResult}function setupStatefulComponent(instance,isSSR){const Component=instance.type;if(Component.name&&validateComponentName(Component.name,instance.appContext.config),Component.components){const names=Object.keys(Component.components);for(let i=0;i<names.length;i++)validateComponentName(names[i],instance.appContext.config)}if(Component.directives){const names=Object.keys(Component.directives);for(let i=0;i<names.length;i++)validateDirectiveName(names[i])}instance.accessCache={},instance.proxy=new Proxy(instance.ctx,PublicInstanceProxyHandlers),exposePropsOnRenderContext(instance);const{setup:setup}=Component;if(setup){const setupContext=instance.setupContext=setup.length>1?createSetupContext(instance):null;currentInstance=instance,pauseTracking();const setupResult=callWithErrorHandling(setup,instance,0,[shallowReadonly(instance.props),setupContext]);if(resetTracking(),currentInstance=null,isPromise(setupResult)){if(isSSR)return setupResult.then(resolvedResult=>{handleSetupResult(instance,resolvedResult)});instance.asyncDep=setupResult}else handleSetupResult(instance,setupResult)}else finishComponentSetup(instance)}function handleSetupResult(instance,setupResult,isSSR){isFunction(setupResult)?instance.render=setupResult:isObject(setupResult)?(isVNode(setupResult)&&warn("setup() should not return VNodes directly - return a render function instead."),instance.devtoolsRawSetupState=setupResult,instance.setupState=proxyRefs(setupResult),exposeSetupStateOnRenderContext(instance)):void 0!==setupResult&&warn(`setup() should return an object. Received: ${null===setupResult?"null":typeof setupResult}`),finishComponentSetup(instance)}function registerRuntimeCompiler(_compile){compile=_compile}function finishComponentSetup(instance,isSSR){const Component=instance.type;instance.render||(compile&&Component.template&&!Component.render&&(startMeasure(instance,"compile"),Component.render=compile(Component.template,{isCustomElement:instance.appContext.config.isCustomElement,delimiters:Component.delimiters}),endMeasure(instance,"compile")),instance.render=Component.render||NOOP,instance.render._rc&&(instance.withProxy=new Proxy(instance.ctx,RuntimeCompiledPublicInstanceProxyHandlers))),currentInstance=instance,applyOptions(instance,Component),currentInstance=null,Component.render||instance.render!==NOOP||(!compile&&Component.template?warn('Component provided template option but runtime compilation is not supported in this build of Vue. Use "vue.global.js" instead.'):warn("Component is missing template or render function."))}const attrHandlers={get:(target,key)=>(markAttrsAccessed(),target[key]),set:()=>(warn("setupContext.attrs is readonly."),!1),deleteProperty:()=>(warn("setupContext.attrs is readonly."),!1)};function createSetupContext(instance){return Object.freeze({get attrs(){return new Proxy(instance.attrs,attrHandlers)},get slots(){return shallowReadonly(instance.slots)},get emit(){return(event,...args)=>instance.emit(event,...args)}})}function recordInstanceBoundEffect(effect){currentInstance&&(currentInstance.effects||(currentInstance.effects=[])).push(effect)}const classifyRE=/(?:^|[-_])(\w)/g,classify=str=>str.replace(classifyRE,c=>c.toUpperCase()).replace(/[-_]/g,"");function formatComponentName(instance,Component,isRoot=!1){let name=isFunction(Component)&&Component.displayName||Component.name;if(!name&&Component.__file){const match=Component.__file.match(/([^/\\]+)\.vue$/);match&&(name=match[1])}if(!name&&instance&&instance.parent){const inferFromRegistry=registry=>{for(const key in registry)if(registry[key]===Component)return key};name=inferFromRegistry(instance.components||instance.parent.type.components)||inferFromRegistry(instance.appContext.components)}return name?classify(name):isRoot?"App":"Anonymous"}function isClassComponent(value){return isFunction(value)&&"__vccOpts"in value}function computed$1(getterOrOptions){const c=computed(getterOrOptions);return recordInstanceBoundEffect(c.effect),c}function defineComponent(options){return isFunction(options)?{setup:options,name:options.name}:options}function defineAsyncComponent(source){isFunction(source)&&(source={loader:source});const{loader:loader,loadingComponent:loadingComponent,errorComponent:errorComponent,delay:delay=200,timeout:timeout,suspensible:suspensible=!0,onError:userOnError}=source;let pendingRequest=null,resolvedComp,retries=0;const retry=()=>(retries++,pendingRequest=null,load()),load=()=>{let thisRequest;return pendingRequest||(thisRequest=pendingRequest=loader().catch(err=>{if(err=err instanceof Error?err:new Error(String(err)),userOnError)return new Promise((resolve,reject)=>{const userRetry=()=>resolve(retry()),userFail=()=>reject(err);userOnError(err,userRetry,userFail,retries+1)});throw err}).then(comp=>{if(thisRequest!==pendingRequest&&pendingRequest)return pendingRequest;if(comp||warn("Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."),comp&&(comp.__esModule||"Module"===comp[Symbol.toStringTag])&&(comp=comp.default),comp&&!isObject(comp)&&!isFunction(comp))throw new Error(`Invalid async component load result: ${comp}`);return resolvedComp=comp,comp}))};return defineComponent({__asyncLoader:load,name:"AsyncComponentWrapper",setup(){const instance=currentInstance;if(resolvedComp)return()=>createInnerComp(resolvedComp,instance);const onError=err=>{pendingRequest=null,handleError(err,instance,13,!errorComponent)};if(suspensible&&instance.suspense)return load().then(comp=>()=>createInnerComp(comp,instance)).catch(err=>(onError(err),()=>errorComponent?createVNode(errorComponent,{error:err}):null));const loaded=ref(!1),error=ref(),delayed=ref(!!delay);return delay&&setTimeout(()=>{delayed.value=!1},delay),null!=timeout&&setTimeout(()=>{if(!loaded.value&&!error.value){const err=new Error(`Async component timed out after ${timeout}ms.`);onError(err),error.value=err}},timeout),load().then(()=>{loaded.value=!0}).catch(err=>{onError(err),error.value=err}),()=>loaded.value&&resolvedComp?createInnerComp(resolvedComp,instance):error.value&&errorComponent?createVNode(errorComponent,{error:error.value}):loadingComponent&&!delayed.value?createVNode(loadingComponent):void 0}})}function createInnerComp(comp,{vnode:{props:props,children:children}}){return createVNode(comp,props,children)}function h(type,propsOrChildren,children){const l=arguments.length;return 2===l?isObject(propsOrChildren)&&!isArray(propsOrChildren)?isVNode(propsOrChildren)?createVNode(type,null,[propsOrChildren]):createVNode(type,propsOrChildren):createVNode(type,null,propsOrChildren):(l>3?children=Array.prototype.slice.call(arguments,2):3===l&&isVNode(children)&&(children=[children]),createVNode(type,propsOrChildren,children))}const ssrContextKey=Symbol("ssrContext"),useSSRContext=()=>{warn("useSsrContext() is not supported in the global build.")};function renderList(source,renderItem){let ret;if(isArray(source)||isString(source)){ret=new Array(source.length);for(let i=0,l=source.length;i<l;i++)ret[i]=renderItem(source[i],i)}else if("number"==typeof source){ret=new Array(source);for(let i=0;i<source;i++)ret[i]=renderItem(i+1,i)}else if(isObject(source))if(source[Symbol.iterator])ret=Array.from(source,renderItem);else{const keys=Object.keys(source);ret=new Array(keys.length);for(let i=0,l=keys.length;i<l;i++){const key=keys[i];ret[i]=renderItem(source[key],key,i)}}else ret=[];return ret}function toHandlers(obj){const ret={};if(!isObject(obj))return warn("v-on with no argument expects an object value."),ret;for(const key in obj)ret[`on${capitalize(key)}`]=obj[key];return ret}function createSlots(slots,dynamicSlots){for(let i=0;i<dynamicSlots.length;i++){const slot=dynamicSlots[i];if(isArray(slot))for(let j=0;j<slot.length;j++)slots[slot[j].name]=slot[j].fn;else slot&&(slots[slot.name]=slot.fn)}return slots}const version="3.0.0",ssrUtils=null,svgNS="http://www.w3.org/2000/svg",doc="undefined"!=typeof document?document:null;let tempContainer,tempSVGContainer;const nodeOps={insert:(child,parent,anchor)=>{parent.insertBefore(child,anchor||null)},remove:child=>{const parent=child.parentNode;parent&&parent.removeChild(child)},createElement:(tag,isSVG,is)=>isSVG?doc.createElementNS(svgNS,tag):doc.createElement(tag,is?{is:is}:void 0),createText:text=>doc.createTextNode(text),createComment:text=>doc.createComment(text),setText:(node,text)=>{node.nodeValue=text},setElementText:(el,text)=>{el.textContent=text},parentNode:node=>node.parentNode,nextSibling:node=>node.nextSibling,querySelector:selector=>doc.querySelector(selector),setScopeId(el,id){el.setAttribute(id,"")},cloneNode:el=>el.cloneNode(!0),insertStaticContent(content,parent,anchor,isSVG){const temp=isSVG?tempSVGContainer||(tempSVGContainer=doc.createElementNS(svgNS,"svg")):tempContainer||(tempContainer=doc.createElement("div"));temp.innerHTML=content;const first=temp.firstChild;let node=first,last=node;for(;node;)last=node,nodeOps.insert(node,parent,anchor),node=temp.firstChild;return[first,last]}};function patchClass(el,value,isSVG){if(null==value&&(value=""),isSVG)el.setAttribute("class",value);else{const transitionClasses=el._vtc;transitionClasses&&(value=(value?[value,...transitionClasses]:[...transitionClasses]).join(" ")),el.className=value}}function patchStyle(el,prev,next){const style=el.style;if(next)if(isString(next))prev!==next&&(style.cssText=next);else{for(const key in next)setStyle(style,key,next[key]);if(prev&&!isString(prev))for(const key in prev)null==next[key]&&setStyle(style,key,"")}else el.removeAttribute("style")}const importantRE=/\s*!important$/;function setStyle(style,name,val){if(isArray(val))val.forEach(v=>setStyle(style,name,v));else if(name.startsWith("--"))style.setProperty(name,val);else{const prefixed=autoPrefix(style,name);importantRE.test(val)?style.setProperty(hyphenate(prefixed),val.replace(importantRE,""),"important"):style[prefixed]=val}}const prefixes=["Webkit","Moz","ms"],prefixCache={};function autoPrefix(style,rawName){const cached=prefixCache[rawName];if(cached)return cached;let name=camelize(rawName);if("filter"!==name&&name in style)return prefixCache[rawName]=name;name=capitalize(name);for(let i=0;i<prefixes.length;i++){const prefixed=prefixes[i]+name;if(prefixed in style)return prefixCache[rawName]=prefixed}return rawName}const xlinkNS="http://www.w3.org/1999/xlink";function patchAttr(el,key,value,isSVG){if(isSVG&&key.startsWith("xlink:"))null==value?el.removeAttributeNS(xlinkNS,key.slice(6,key.length)):el.setAttributeNS(xlinkNS,key,value);else{const isBoolean=isSpecialBooleanAttr(key);null==value||isBoolean&&!1===value?el.removeAttribute(key):el.setAttribute(key,isBoolean?"":value)}}function patchDOMProp(el,key,value,prevChildren,parentComponent,parentSuspense,unmountChildren){if("innerHTML"===key||"textContent"===key)return prevChildren&&unmountChildren(prevChildren,parentComponent,parentSuspense),void(el[key]=null==value?"":value);if("value"!==key||"PROGRESS"===el.tagName)if(""===value&&"boolean"==typeof el[key])el[key]=!0;else if(null==value&&"string"==typeof el[key])el[key]="",el.removeAttribute(key);else try{el[key]=value}catch(e){warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: `+`value ${value} is invalid.`,e)}else{el._value=value;const newValue=null==value?"":value;el.value!==newValue&&(el.value=newValue)}}let _getNow=Date.now;"undefined"!=typeof document&&_getNow()>document.createEvent("Event").timeStamp&&(_getNow=()=>performance.now());let cachedNow=0;const p=Promise.resolve(),reset=()=>{cachedNow=0},getNow=()=>cachedNow||(p.then(reset),cachedNow=_getNow());function addEventListener(el,event,handler,options){el.addEventListener(event,handler,options)}function removeEventListener(el,event,handler,options){el.removeEventListener(event,handler,options)}function patchEvent(el,rawName,prevValue,nextValue,instance=null){const invokers=el._vei||(el._vei={}),existingInvoker=invokers[rawName];if(nextValue&&existingInvoker)existingInvoker.value=nextValue;else{const[name,options]=parseName(rawName);if(nextValue){const invoker=invokers[rawName]=createInvoker(nextValue,instance);addEventListener(el,name,invoker,options)}else existingInvoker&&(removeEventListener(el,name,existingInvoker,options),invokers[rawName]=void 0)}}const optionsModifierRE=/(?:Once|Passive|Capture)$/;function parseName(name){let options;if(optionsModifierRE.test(name)){let m;for(options={};m=name.match(optionsModifierRE);)name=name.slice(0,name.length-m[0].length),options[m[0].toLowerCase()]=!0}return[name.slice(2).toLowerCase(),options]}function createInvoker(initialValue,instance){const invoker=e=>{const timeStamp=e.timeStamp||_getNow();timeStamp>=invoker.attached-1&&callWithAsyncErrorHandling(patchStopImmediatePropagation(e,invoker.value),instance,5,[e])};return invoker.value=initialValue,invoker.attached=getNow(),invoker}function patchStopImmediatePropagation(e,value){if(isArray(value)){const originalStop=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{originalStop.call(e),e._stopped=!0},value.map(fn=>e=>!e._stopped&&fn(e))}return value}const nativeOnRE=/^on[a-z]/,forcePatchProp=(_,key)=>"value"===key,patchProp=(el,key,prevValue,nextValue,isSVG=!1,prevChildren,parentComponent,parentSuspense,unmountChildren)=>{switch(key){case"class":patchClass(el,nextValue,isSVG);break;case"style":patchStyle(el,prevValue,nextValue);break;default:isOn(key)?isModelListener(key)||patchEvent(el,key,prevValue,nextValue,parentComponent):shouldSetAsProp(el,key,nextValue,isSVG)?patchDOMProp(el,key,nextValue,prevChildren,parentComponent,parentSuspense,unmountChildren):("true-value"===key?el._trueValue=nextValue:"false-value"===key&&(el._falseValue=nextValue),patchAttr(el,key,nextValue,isSVG))}};function shouldSetAsProp(el,key,value,isSVG){return isSVG?"innerHTML"===key||!!(key in el&&nativeOnRE.test(key)&&isFunction(value)):"spellcheck"!==key&&"draggable"!==key&&(("form"!==key||"string"!=typeof value)&&(("list"!==key||"INPUT"!==el.tagName)&&((!nativeOnRE.test(key)||!isString(value))&&key in el)))}function useCssModule(name="$style"){return warn("useCssModule() is not supported in the global build."),EMPTY_OBJ}function useCssVars(getter,scoped=!1){const instance=getCurrentInstance();if(!instance)return void warn("useCssVars is called without current active component instance.");const prefix=scoped&&instance.type.__scopeId?`${instance.type.__scopeId.replace(/^data-v-/,"")}-`:"";onMounted(()=>{watchEffect(()=>{setVarsOnVNode(instance.subTree,getter(instance.proxy),prefix)})})}function setVarsOnVNode(vnode,vars,prefix){if(128&vnode.shapeFlag){const suspense=vnode.suspense;vnode=suspense.activeBranch,suspense.pendingBranch&&!suspense.isHydrating&&suspense.effects.push(()=>{setVarsOnVNode(suspense.activeBranch,vars,prefix)})}for(;vnode.component;)vnode=vnode.component.subTree;if(1&vnode.shapeFlag&&vnode.el){const style=vnode.el.style;for(const key in vars)style.setProperty(`--${prefix}${key}`,unref(vars[key]))}else vnode.type===Fragment&&vnode.children.forEach(c=>setVarsOnVNode(c,vars,prefix))}const TRANSITION="transition",ANIMATION="animation",Transition=(props,{slots:slots})=>h(BaseTransition,resolveTransitionProps(props),slots);Transition.displayName="Transition";const DOMTransitionPropsValidators={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},TransitionPropsValidators=Transition.props=extend({},BaseTransition.props,DOMTransitionPropsValidators);function resolveTransitionProps(rawProps){let{name:name="v",type:type,css:css=!0,duration:duration,enterFromClass:enterFromClass=`${name}-enter-from`,enterActiveClass:enterActiveClass=`${name}-enter-active`,enterToClass:enterToClass=`${name}-enter-to`,appearFromClass:appearFromClass=enterFromClass,appearActiveClass:appearActiveClass=enterActiveClass,appearToClass:appearToClass=enterToClass,leaveFromClass:leaveFromClass=`${name}-leave-from`,leaveActiveClass:leaveActiveClass=`${name}-leave-active`,leaveToClass:leaveToClass=`${name}-leave-to`}=rawProps;const baseProps={};for(const key in rawProps)key in DOMTransitionPropsValidators||(baseProps[key]=rawProps[key]);if(!css)return baseProps;const durations=normalizeDuration(duration),enterDuration=durations&&durations[0],leaveDuration=durations&&durations[1],{onBeforeEnter:onBeforeEnter,onEnter:onEnter,onEnterCancelled:onEnterCancelled,onLeave:onLeave,onLeaveCancelled:onLeaveCancelled,onBeforeAppear:onBeforeAppear=onBeforeEnter,onAppear:onAppear=onEnter,onAppearCancelled:onAppearCancelled=onEnterCancelled}=baseProps,finishEnter=(el,isAppear,done)=>{removeTransitionClass(el,isAppear?appearToClass:enterToClass),removeTransitionClass(el,isAppear?appearActiveClass:enterActiveClass),done&&done()},finishLeave=(el,done)=>{removeTransitionClass(el,leaveToClass),removeTransitionClass(el,leaveActiveClass),done&&done()},makeEnterHook=isAppear=>(el,done)=>{const hook=isAppear?onAppear:onEnter,resolve=()=>finishEnter(el,isAppear,done);hook&&hook(el,resolve),nextFrame(()=>{removeTransitionClass(el,isAppear?appearFromClass:enterFromClass),addTransitionClass(el,isAppear?appearToClass:enterToClass),hook&&hook.length>1||(enterDuration?setTimeout(resolve,enterDuration):whenTransitionEnds(el,type,resolve))})};return extend(baseProps,{onBeforeEnter(el){onBeforeEnter&&onBeforeEnter(el),addTransitionClass(el,enterActiveClass),addTransitionClass(el,enterFromClass)},onBeforeAppear(el){onBeforeAppear&&onBeforeAppear(el),addTransitionClass(el,appearActiveClass),addTransitionClass(el,appearFromClass)},onEnter:makeEnterHook(!1),onAppear:makeEnterHook(!0),onLeave(el,done){const resolve=()=>finishLeave(el,done);addTransitionClass(el,leaveActiveClass),addTransitionClass(el,leaveFromClass),nextFrame(()=>{removeTransitionClass(el,leaveFromClass),addTransitionClass(el,leaveToClass),onLeave&&onLeave.length>1||(leaveDuration?setTimeout(resolve,leaveDuration):whenTransitionEnds(el,type,resolve))}),onLeave&&onLeave(el,resolve)},onEnterCancelled(el){finishEnter(el,!1),onEnterCancelled&&onEnterCancelled(el)},onAppearCancelled(el){finishEnter(el,!0),onAppearCancelled&&onAppearCancelled(el)},onLeaveCancelled(el){finishLeave(el),onLeaveCancelled&&onLeaveCancelled(el)}})}function normalizeDuration(duration){if(null==duration)return null;if(isObject(duration))return[NumberOf(duration.enter),NumberOf(duration.leave)];{const n=NumberOf(duration);return[n,n]}}function NumberOf(val){const res=toNumber(val);return validateDuration(res),res}function validateDuration(val){"number"!=typeof val?warn("<transition> explicit duration is not a valid number - "+`got ${JSON.stringify(val)}.`):isNaN(val)&&warn("<transition> explicit duration is NaN - the duration expression might be incorrect.")}function addTransitionClass(el,cls){cls.split(/\s+/).forEach(c=>c&&el.classList.add(c)),(el._vtc||(el._vtc=new Set)).add(cls)}function removeTransitionClass(el,cls){cls.split(/\s+/).forEach(c=>c&&el.classList.remove(c));const{_vtc:_vtc}=el;_vtc&&(_vtc.delete(cls),_vtc.size||(el._vtc=void 0))}function nextFrame(cb){requestAnimationFrame(()=>{requestAnimationFrame(cb)})}function whenTransitionEnds(el,expectedType,cb){const{type:type,timeout:timeout,propCount:propCount}=getTransitionInfo(el,expectedType);if(!type)return cb();const endEvent=type+"end";let ended=0;const end=()=>{el.removeEventListener(endEvent,onEnd),cb()},onEnd=e=>{e.target===el&&++ended>=propCount&&end()};setTimeout(()=>{ended<propCount&&end()},timeout+1),el.addEventListener(endEvent,onEnd)}function getTransitionInfo(el,expectedType){const styles=window.getComputedStyle(el),getStyleProperties=key=>(styles[key]||"").split(", "),transitionDelays=getStyleProperties("transitionDelay"),transitionDurations=getStyleProperties("transitionDuration"),transitionTimeout=getTimeout(transitionDelays,transitionDurations),animationDelays=getStyleProperties("animationDelay"),animationDurations=getStyleProperties("animationDuration"),animationTimeout=getTimeout(animationDelays,animationDurations);let type=null,timeout=0,propCount=0;expectedType===TRANSITION?transitionTimeout>0&&(type=TRANSITION,timeout=transitionTimeout,propCount=transitionDurations.length):expectedType===ANIMATION?animationTimeout>0&&(type=ANIMATION,timeout=animationTimeout,propCount=animationDurations.length):(timeout=Math.max(transitionTimeout,animationTimeout),type=timeout>0?transitionTimeout>animationTimeout?TRANSITION:ANIMATION:null,propCount=type?type===TRANSITION?transitionDurations.length:animationDurations.length:0);const hasTransform=type===TRANSITION&&/\b(transform|all)(,|$)/.test(styles.transitionProperty);return{type:type,timeout:timeout,propCount:propCount,hasTransform:hasTransform}}function getTimeout(delays,durations){for(;delays.length<durations.length;)delays=delays.concat(delays);return Math.max(...durations.map((d,i)=>toMs(d)+toMs(delays[i])))}function toMs(s){return 1e3*Number(s.slice(0,-1).replace(",","."))}const positionMap=new WeakMap,newPositionMap=new WeakMap,TransitionGroupImpl={name:"TransitionGroup",props:extend({},TransitionPropsValidators,{tag:String,moveClass:String}),setup(props,{slots:slots}){const instance=getCurrentInstance(),state=useTransitionState();let prevChildren,children;return onUpdated(()=>{if(!prevChildren.length)return;const moveClass=props.moveClass||`${props.name||"v"}-move`;if(!hasCSSTransform(prevChildren[0].el,instance.vnode.el,moveClass))return;prevChildren.forEach(callPendingCbs),prevChildren.forEach(recordPosition);const movedChildren=prevChildren.filter(applyTranslation);forceReflow(),movedChildren.forEach(c=>{const el=c.el,style=el.style;addTransitionClass(el,moveClass),style.transform=style.webkitTransform=style.transitionDuration="";const cb=el._moveCb=e=>{e&&e.target!==el||e&&!/transform$/.test(e.propertyName)||(el.removeEventListener("transitionend",cb),el._moveCb=null,removeTransitionClass(el,moveClass))};el.addEventListener("transitionend",cb)})}),()=>{const rawProps=toRaw(props),cssTransitionProps=resolveTransitionProps(rawProps),tag=rawProps.tag||Fragment;prevChildren=children,children=slots.default?getTransitionRawChildren(slots.default()):[];for(let i=0;i<children.length;i++){const child=children[i];null!=child.key?setTransitionHooks(child,resolveTransitionHooks(child,cssTransitionProps,state,instance)):warn("<TransitionGroup> children must be keyed.")}if(prevChildren)for(let i=0;i<prevChildren.length;i++){const child=prevChildren[i];setTransitionHooks(child,resolveTransitionHooks(child,cssTransitionProps,state,instance)),positionMap.set(child,child.el.getBoundingClientRect())}return createVNode(tag,null,children)}}},TransitionGroup=TransitionGroupImpl;function callPendingCbs(c){const el=c.el;el._moveCb&&el._moveCb(),el._enterCb&&el._enterCb()}function recordPosition(c){newPositionMap.set(c,c.el.getBoundingClientRect())}function applyTranslation(c){const oldPos=positionMap.get(c),newPos=newPositionMap.get(c),dx=oldPos.left-newPos.left,dy=oldPos.top-newPos.top;if(dx||dy){const s=c.el.style;return s.transform=s.webkitTransform=`translate(${dx}px,${dy}px)`,s.transitionDuration="0s",c}}function forceReflow(){return document.body.offsetHeight}function hasCSSTransform(el,root,moveClass){const clone=el.cloneNode();el._vtc&&el._vtc.forEach(cls=>{cls.split(/\s+/).forEach(c=>c&&clone.classList.remove(c))}),moveClass.split(/\s+/).forEach(c=>c&&clone.classList.add(c)),clone.style.display="none";const container=1===root.nodeType?root:root.parentNode;container.appendChild(clone);const{hasTransform:hasTransform}=getTransitionInfo(clone);return container.removeChild(clone),hasTransform}const getModelAssigner=vnode=>{const fn=vnode.props["onUpdate:modelValue"];return isArray(fn)?value=>invokeArrayFns(fn,value):fn};function onCompositionStart(e){e.target.composing=!0}function onCompositionEnd(e){const target=e.target;target.composing&&(target.composing=!1,trigger$1(target,"input"))}function trigger$1(el,type){const e=document.createEvent("HTMLEvents");e.initEvent(type,!0,!0),el.dispatchEvent(e)}const vModelText={created(el,{value:value,modifiers:{lazy:lazy,trim:trim,number:number}},vnode){el.value=null==value?"":value,el._assign=getModelAssigner(vnode);const castToNumber=number||"number"===el.type;addEventListener(el,lazy?"change":"input",e=>{if(e.target.composing)return;let domValue=el.value;trim?domValue=domValue.trim():castToNumber&&(domValue=toNumber(domValue)),el._assign(domValue)}),trim&&addEventListener(el,"change",()=>{el.value=el.value.trim()}),lazy||(addEventListener(el,"compositionstart",onCompositionStart),addEventListener(el,"compositionend",onCompositionEnd),addEventListener(el,"change",onCompositionEnd))},beforeUpdate(el,{value:value,modifiers:{trim:trim,number:number}},vnode){if(el._assign=getModelAssigner(vnode),document.activeElement===el){if(trim&&el.value.trim()===value)return;if((number||"number"===el.type)&&toNumber(el.value)===value)return}const newValue=null==value?"":value;el.value!==newValue&&(el.value=newValue)}},vModelCheckbox={created(el,binding,vnode){setChecked(el,binding,vnode),el._assign=getModelAssigner(vnode),addEventListener(el,"change",()=>{const modelValue=el._modelValue,elementValue=getValue(el),checked=el.checked,assign=el._assign;if(isArray(modelValue)){const index=looseIndexOf(modelValue,elementValue),found=-1!==index;if(checked&&!found)assign(modelValue.concat(elementValue));else if(!checked&&found){const filtered=[...modelValue];filtered.splice(index,1),assign(filtered)}}else if(isSet(modelValue)){const found=modelValue.has(elementValue);checked&&!found?assign(modelValue.add(elementValue)):!checked&&found&&(modelValue.delete(elementValue),assign(modelValue))}else assign(getCheckboxValue(el,checked))})},beforeUpdate(el,binding,vnode){el._assign=getModelAssigner(vnode),setChecked(el,binding,vnode)}};function setChecked(el,{value:value,oldValue:oldValue},vnode){el._modelValue=value,isArray(value)?el.checked=looseIndexOf(value,vnode.props.value)>-1:isSet(value)?el.checked=looseHas(value,vnode.props.value):value!==oldValue&&(el.checked=looseEqual(value,getCheckboxValue(el,!0)))}const vModelRadio={created(el,{value:value},vnode){el.checked=looseEqual(value,vnode.props.value),el._assign=getModelAssigner(vnode),addEventListener(el,"change",()=>{el._assign(getValue(el))})},beforeUpdate(el,{value:value,oldValue:oldValue},vnode){el._assign=getModelAssigner(vnode),value!==oldValue&&(el.checked=looseEqual(value,vnode.props.value))}},vModelSelect={created(el,binding,vnode){addEventListener(el,"change",()=>{const selectedVal=Array.prototype.filter.call(el.options,o=>o.selected).map(getValue);el._assign(el.multiple?selectedVal:selectedVal[0])}),el._assign=getModelAssigner(vnode)},mounted(el,{value:value}){setSelected(el,value)},beforeUpdate(el,_binding,vnode){el._assign=getModelAssigner(vnode)},updated(el,{value:value}){setSelected(el,value)}};function setSelected(el,value){const isMultiple=el.multiple;if(!isMultiple||isArray(value)||isSet(value)){for(let i=0,l=el.options.length;i<l;i++){const option=el.options[i],optionValue=getValue(option);if(isMultiple)isArray(value)?option.selected=looseIndexOf(value,optionValue)>-1:option.selected=looseHas(value,optionValue);else if(looseEqual(getValue(option),value))return void(el.selectedIndex=i)}isMultiple||(el.selectedIndex=-1)}else warn("<select multiple v-model> expects an Array or Set value for its binding, "+`but got ${Object.prototype.toString.call(value).slice(8,-1)}.`)}function getValue(el){return"_value"in el?el._value:el.value}function getCheckboxValue(el,checked){const key=checked?"_trueValue":"_falseValue";return key in el?el[key]:checked}const vModelDynamic={created(el,binding,vnode){callModelHook(el,binding,vnode,null,"created")},mounted(el,binding,vnode){callModelHook(el,binding,vnode,null,"mounted")},beforeUpdate(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,"beforeUpdate")},updated(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,"updated")}};function callModelHook(el,binding,vnode,prevVNode,hook){let modelToUse;switch(el.tagName){case"SELECT":modelToUse=vModelSelect;break;case"TEXTAREA":modelToUse=vModelText;break;default:switch(vnode.props&&vnode.props.type){case"checkbox":modelToUse=vModelCheckbox;break;case"radio":modelToUse=vModelRadio;break;default:modelToUse=vModelText}}const fn=modelToUse[hook];fn&&fn(el,binding,vnode,prevVNode)}const systemModifiers=["ctrl","shift","alt","meta"],modifierGuards={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&0!==e.button,middle:e=>"button"in e&&1!==e.button,right:e=>"button"in e&&2!==e.button,exact:(e,modifiers)=>systemModifiers.some(m=>e[`${m}Key`]&&!modifiers.includes(m))},withModifiers=(fn,modifiers)=>(event,...args)=>{for(let i=0;i<modifiers.length;i++){const guard=modifierGuards[modifiers[i]];if(guard&&guard(event,modifiers))return}return fn(event,...args)},keyNames={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},withKeys=(fn,modifiers)=>event=>{if(!("key"in event))return;const eventKey=hyphenate(event.key);return modifiers.some(k=>k===eventKey||keyNames[k]===eventKey)?fn(event):void 0},vShow={beforeMount(el,{value:value},{transition:transition}){el._vod="none"===el.style.display?"":el.style.display,transition&&value?transition.beforeEnter(el):setDisplay(el,value)},mounted(el,{value:value},{transition:transition}){transition&&value&&transition.enter(el)},updated(el,{value:value,oldValue:oldValue},{transition:transition}){!value!=!oldValue&&(transition?value?(transition.beforeEnter(el),setDisplay(el,!0),transition.enter(el)):transition.leave(el,()=>{setDisplay(el,!1)}):setDisplay(el,value))},beforeUnmount(el,{value:value}){setDisplay(el,value)}};function setDisplay(el,value){el.style.display=value?el._vod:"none"}const rendererOptions=extend({patchProp:patchProp,forcePatchProp:forcePatchProp},nodeOps);let renderer,enabledHydration=!1;function ensureRenderer(){return renderer||(renderer=createRenderer(rendererOptions))}function ensureHydrationRenderer(){return renderer=enabledHydration?renderer:createHydrationRenderer(rendererOptions),enabledHydration=!0,renderer}const render=(...args)=>{ensureRenderer().render(...args)},hydrate=(...args)=>{ensureHydrationRenderer().hydrate(...args)},createApp=(...args)=>{const app=ensureRenderer().createApp(...args);injectNativeTagCheck(app);const{mount:mount}=app;return app.mount=containerOrSelector=>{const container=normalizeContainer(containerOrSelector);if(!container)return;const component=app._component;isFunction(component)||component.render||component.template||(component.template=container.innerHTML),container.innerHTML="";const proxy=mount(container);return container.removeAttribute("v-cloak"),container.setAttribute("data-v-app",""),proxy},app},createSSRApp=(...args)=>{const app=ensureHydrationRenderer().createApp(...args);injectNativeTagCheck(app);const{mount:mount}=app;return app.mount=containerOrSelector=>{const container=normalizeContainer(containerOrSelector);if(container)return mount(container,!0)},app};function injectNativeTagCheck(app){Object.defineProperty(app.config,"isNativeTag",{value:tag=>isHTMLTag(tag)||isSVGTag(tag),writable:!1})}function normalizeContainer(container){if(isString(container)){const res=document.querySelector(container);return res||warn("Failed to mount app: mount target selector returned null."),res}return container}function initDev(){const target=getGlobalThis();target.__VUE__=!0,setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__),console.info("You are running a development build of Vue.\nMake sure to use the production build (*.prod.js) when deploying for production.")}function defaultOnError(error){throw error}function createCompilerError(code,loc,messages,additionalMessage){const msg=(messages||errorMessages)[code]+(additionalMessage||""),error=new SyntaxError(String(msg));return error.code=code,error.loc=loc,error}const errorMessages={0:"Illegal comment.",1:"CDATA section is allowed only in XML context.",2:"Duplicate attribute.",3:"End tag cannot have attributes.",4:"Illegal '/' in tags.",5:"Unexpected EOF in tag.",6:"Unexpected EOF in CDATA section.",7:"Unexpected EOF in comment.",8:"Unexpected EOF in script.",9:"Unexpected EOF in tag.",10:"Incorrectly closed comment.",11:"Incorrectly opened comment.",12:"Illegal tag name. Use '&lt;' to print '<'.",13:"Attribute value was expected.",14:"End tag name was expected.",15:"Whitespace was expected.",16:"Unexpected '\x3c!--' in comment.",17:"Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).",18:"Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",19:"Attribute name cannot start with '='.",21:"'<?' is allowed only in XML context.",22:"Illegal '/' in tags.",23:"Invalid end tag.",24:"Element is missing end tag.",25:"Interpolation end sign was not found.",26:"End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",27:"v-if/v-else-if is missing expression.",28:"v-if/else branches must use unique keys.",29:"v-else/v-else-if has no adjacent v-if.",30:"v-for is missing expression.",31:"v-for has invalid expression.",32:"<template v-for> key should be placed on the <template> tag.",33:"v-bind is missing expression.",34:"v-on is missing expression.",35:"Unexpected custom directive on <slot> outlet.",36:"Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",37:"Duplicate slot names found. ",38:"Extraneous children found when component already has explicitly named default slot. These children will be ignored.",39:"v-slot can only be used on components or <template> tags.",40:"v-model is missing expression.",41:"v-model value must be a valid JavaScript member expression.",42:"v-model cannot be used on v-for or v-slot scope variables because they are not writable.",43:"Error parsing JavaScript expression: ",44:"<KeepAlive> expects exactly one child component.",45:'"prefixIdentifiers" option is not supported in this build of compiler.',46:"ES module mode is not supported in this build of compiler.",47:'"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',48:'"scopeId" option is only supported in module mode.'},FRAGMENT=Symbol("Fragment"),TELEPORT=Symbol("Teleport"),SUSPENSE=Symbol("Suspense"),KEEP_ALIVE=Symbol("KeepAlive"),BASE_TRANSITION=Symbol("BaseTransition"),OPEN_BLOCK=Symbol("openBlock"),CREATE_BLOCK=Symbol("createBlock"),CREATE_VNODE=Symbol("createVNode"),CREATE_COMMENT=Symbol("createCommentVNode"),CREATE_TEXT=Symbol("createTextVNode"),CREATE_STATIC=Symbol("createStaticVNode"),RESOLVE_COMPONENT=Symbol("resolveComponent"),RESOLVE_DYNAMIC_COMPONENT=Symbol("resolveDynamicComponent"),RESOLVE_DIRECTIVE=Symbol("resolveDirective"),WITH_DIRECTIVES=Symbol("withDirectives"),RENDER_LIST=Symbol("renderList"),RENDER_SLOT=Symbol("renderSlot"),CREATE_SLOTS=Symbol("createSlots"),TO_DISPLAY_STRING=Symbol("toDisplayString"),MERGE_PROPS=Symbol("mergeProps"),TO_HANDLERS=Symbol("toHandlers"),CAMELIZE=Symbol("camelize"),CAPITALIZE=Symbol("capitalize"),SET_BLOCK_TRACKING=Symbol("setBlockTracking"),PUSH_SCOPE_ID=Symbol("pushScopeId"),POP_SCOPE_ID=Symbol("popScopeId"),WITH_SCOPE_ID=Symbol("withScopeId"),WITH_CTX=Symbol("withCtx"),helperNameMap={[FRAGMENT]:"Fragment",[TELEPORT]:"Teleport",[SUSPENSE]:"Suspense",[KEEP_ALIVE]:"KeepAlive",[BASE_TRANSITION]:"BaseTransition",[OPEN_BLOCK]:"openBlock",[CREATE_BLOCK]:"createBlock",[CREATE_VNODE]:"createVNode",[CREATE_COMMENT]:"createCommentVNode",[CREATE_TEXT]:"createTextVNode",[CREATE_STATIC]:"createStaticVNode",[RESOLVE_COMPONENT]:"resolveComponent",[RESOLVE_DYNAMIC_COMPONENT]:"resolveDynamicComponent",[RESOLVE_DIRECTIVE]:"resolveDirective",[WITH_DIRECTIVES]:"withDirectives",[RENDER_LIST]:"renderList",[RENDER_SLOT]:"renderSlot",[CREATE_SLOTS]:"createSlots",[TO_DISPLAY_STRING]:"toDisplayString",[MERGE_PROPS]:"mergeProps",[TO_HANDLERS]:"toHandlers",[CAMELIZE]:"camelize",[CAPITALIZE]:"capitalize",[SET_BLOCK_TRACKING]:"setBlockTracking",[PUSH_SCOPE_ID]:"pushScopeId",[POP_SCOPE_ID]:"popScopeId",[WITH_SCOPE_ID]:"withScopeId",[WITH_CTX]:"withCtx"};function registerRuntimeHelpers(helpers){Object.getOwnPropertySymbols(helpers).forEach(s=>{helperNameMap[s]=helpers[s]})}const locStub={source:"",start:{line:1,column:1,offset:0},end:{line:1,column:1,offset:0}};function createRoot(children,loc=locStub){return{type:0,children:children,helpers:[],components:[],directives:[],hoists:[],imports:[],cached:0,temps:0,codegenNode:void 0,loc:loc}}function createVNodeCall(context,tag,props,children,patchFlag,dynamicProps,directives,isBlock=!1,disableTracking=!1,loc=locStub){return context&&(isBlock?(context.helper(OPEN_BLOCK),context.helper(CREATE_BLOCK)):context.helper(CREATE_VNODE),directives&&context.helper(WITH_DIRECTIVES)),{type:13,tag:tag,props:props,children:children,patchFlag:patchFlag,dynamicProps:dynamicProps,directives:directives,isBlock:isBlock,disableTracking:disableTracking,loc:loc}}function createArrayExpression(elements,loc=locStub){return{type:17,loc:loc,elements:elements}}function createObjectExpression(properties,loc=locStub){return{type:15,loc:loc,properties:properties}}function createObjectProperty(key,value){return{type:16,loc:locStub,key:isString(key)?createSimpleExpression(key,!0):key,value:value}}function createSimpleExpression(content,isStatic,loc=locStub,isConstant=!1){return{type:4,loc:loc,isConstant:isConstant,content:content,isStatic:isStatic}}function createCompoundExpression(children,loc=locStub){return{type:8,loc:loc,children:children}}function createCallExpression(callee,args=[],loc=locStub){return{type:14,loc:loc,callee:callee,arguments:args}}function createFunctionExpression(params,returns,newline=!1,isSlot=!1,loc=locStub){return{type:18,params:params,returns:returns,newline:newline,isSlot:isSlot,loc:loc}}function createConditionalExpression(test,consequent,alternate,newline=!0){return{type:19,test:test,consequent:consequent,alternate:alternate,newline:newline,loc:locStub}}function createCacheExpression(index,value,isVNode=!1){return{type:20,index:index,value:value,isVNode:isVNode,loc:locStub}}const isStaticExp=p=>4===p.type&&p.isStatic,isBuiltInType=(tag,expected)=>tag===expected||tag===hyphenate(expected);function isCoreComponent(tag){return isBuiltInType(tag,"Teleport")?TELEPORT:isBuiltInType(tag,"Suspense")?SUSPENSE:isBuiltInType(tag,"KeepAlive")?KEEP_ALIVE:isBuiltInType(tag,"BaseTransition")?BASE_TRANSITION:void 0}const nonIdentifierRE=/^\d|[^\$\w]/,isSimpleIdentifier=name=>!nonIdentifierRE.test(name),memberExpRE=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\[[^\]]+\])*$/,isMemberExpression=path=>!!path&&memberExpRE.test(path.trim());function getInnerRange(loc,offset,length){const source=loc.source.substr(offset,length),newLoc={source:source,start:advancePositionWithClone(loc.start,loc.source,offset),end:loc.end};return null!=length&&(newLoc.end=advancePositionWithClone(loc.start,loc.source,offset+length)),newLoc}function advancePositionWithClone(pos,source,numberOfCharacters=source.length){return advancePositionWithMutation(extend({},pos),source,numberOfCharacters)}function advancePositionWithMutation(pos,source,numberOfCharacters=source.length){let linesCount=0,lastNewLinePos=-1;for(let i=0;i<numberOfCharacters;i++)10===source.charCodeAt(i)&&(linesCount++,lastNewLinePos=i);return pos.offset+=numberOfCharacters,pos.line+=linesCount,pos.column=-1===lastNewLinePos?pos.column+numberOfCharacters:numberOfCharacters-lastNewLinePos,pos}function assert(condition,msg){if(!condition)throw new Error(msg||"unexpected compiler condition")}function findDir(node,name,allowEmpty=!1){for(let i=0;i<node.props.length;i++){const p=node.props[i];if(7===p.type&&(allowEmpty||p.exp)&&(isString(name)?p.name===name:name.test(p.name)))return p}}function findProp(node,name,dynamicOnly=!1,allowEmpty=!1){for(let i=0;i<node.props.length;i++){const p=node.props[i];if(6===p.type){if(dynamicOnly)continue;if(p.name===name&&(p.value||allowEmpty))return p}else if("bind"===p.name&&(p.exp||allowEmpty)&&isBindKey(p.arg,name))return p}}function isBindKey(arg,name){return!(!arg||!isStaticExp(arg)||arg.content!==name)}function hasDynamicKeyVBind(node){return node.props.some(p=>!(7!==p.type||"bind"!==p.name||p.arg&&4===p.arg.type&&p.arg.isStatic))}function isText(node){return 5===node.type||2===node.type}function isVSlot(p){return 7===p.type&&"slot"===p.name}function isTemplateNode(node){return 1===node.type&&3===node.tagType}function isSlotOutlet(node){return 1===node.type&&2===node.tagType}function injectProp(node,prop,context){let propsWithInjection;const props=13===node.type?node.props:node.arguments[2];if(null==props||isString(props))propsWithInjection=createObjectExpression([prop]);else if(14===props.type){const first=props.arguments[0];isString(first)||15!==first.type?props.arguments.unshift(createObjectExpression([prop])):first.properties.unshift(prop),propsWithInjection=props}else if(15===props.type){let alreadyExists=!1;if(4===prop.key.type){const propKeyName=prop.key.content;alreadyExists=props.properties.some(p=>4===p.key.type&&p.key.content===propKeyName)}alreadyExists||props.properties.unshift(prop),propsWithInjection=props}else propsWithInjection=createCallExpression(context.helper(MERGE_PROPS),[createObjectExpression([prop]),props]);13===node.type?node.props=propsWithInjection:node.arguments[2]=propsWithInjection}function toValidAssetId(name,type){return`_${type}_${name.replace(/[^\w]/g,"_")}`}const decodeRE=/&(gt|lt|amp|apos|quot);/g,decodeMap={gt:">",lt:"<",amp:"&",apos:"'",quot:'"'},defaultParserOptions={delimiters:["{{","}}"],getNamespace:()=>0,getTextMode:()=>0,isVoidTag:NO,isPreTag:NO,isCustomElement:NO,decodeEntities:rawText=>rawText.replace(decodeRE,(_,p1)=>decodeMap[p1]),onError:defaultOnError,comments:!1};function baseParse(content,options={}){const context=createParserContext(content,options),start=getCursor(context);return createRoot(parseChildren(context,0,[]),getSelection(context,start))}function createParserContext(content,rawOptions){const options=extend({},defaultParserOptions);for(const key in rawOptions)options[key]=rawOptions[key]||defaultParserOptions[key];return{options:options,column:1,line:1,offset:0,originalSource:content,source:content,inPre:!1,inVPre:!1}}function parseChildren(context,mode,ancestors){const parent=last(ancestors),ns=parent?parent.ns:0,nodes=[];for(;!isEnd(context,mode,ancestors);){const s=context.source;let node=void 0;if(0===mode||1===mode)if(!context.inVPre&&startsWith(s,context.options.delimiters[0]))node=parseInterpolation(context,mode);else if(0===mode&&"<"===s[0])if(1===s.length)emitError(context,5,1);else if("!"===s[1])startsWith(s,"\x3c!--")?node=parseComment(context):startsWith(s,"<!DOCTYPE")?node=parseBogusComment(context):startsWith(s,"<![CDATA[")?0!==ns?node=parseCDATA(context,ancestors):(emitError(context,1),node=parseBogusComment(context)):(emitError(context,11),node=parseBogusComment(context));else if("/"===s[1])if(2===s.length)emitError(context,5,2);else{if(">"===s[2]){emitError(context,14,2),advanceBy(context,3);continue}if(/[a-z]/i.test(s[2])){emitError(context,23),parseTag(context,1,parent);continue}emitError(context,12,2),node=parseBogusComment(context)}else/[a-z]/i.test(s[1])?node=parseElement(context,ancestors):"?"===s[1]?(emitError(context,21,1),node=parseBogusComment(context)):emitError(context,12,1);if(node||(node=parseText(context,mode)),isArray(node))for(let i=0;i<node.length;i++)pushNode(nodes,node[i]);else pushNode(nodes,node)}let removedWhitespace=!1;if(2!==mode)if(context.inPre){if(parent&&context.options.isPreTag(parent.tag)){const first=nodes[0];first&&2===first.type&&(first.content=first.content.replace(/^\r?\n/,""))}}else for(let i=0;i<nodes.length;i++){const node=nodes[i];if(2===node.type)if(/[^\t\r\n\f ]/.test(node.content))node.content=node.content.replace(/[\t\r\n\f ]+/g," ");else{const prev=nodes[i-1],next=nodes[i+1];!prev||!next||3===prev.type||3===next.type||1===prev.type&&1===next.type&&/[\r\n]/.test(node.content)?(removedWhitespace=!0,nodes[i]=null):node.content=" "}}return removedWhitespace?nodes.filter(Boolean):nodes}function pushNode(nodes,node){if(2===node.type){const prev=last(nodes);if(prev&&2===prev.type&&prev.loc.end.offset===node.loc.start.offset)return prev.content+=node.content,prev.loc.end=node.loc.end,void(prev.loc.source+=node.loc.source)}nodes.push(node)}function parseCDATA(context,ancestors){advanceBy(context,9);const nodes=parseChildren(context,3,ancestors);return 0===context.source.length?emitError(context,6):advanceBy(context,3),nodes}function parseComment(context){const start=getCursor(context);let content;const match=/--(\!)?>/.exec(context.source);if(match){match.index<=3&&emitError(context,0),match[1]&&emitError(context,10),content=context.source.slice(4,match.index);const s=context.source.slice(0,match.index);let prevIndex=1,nestedIndex=0;for(;-1!==(nestedIndex=s.indexOf("\x3c!--",prevIndex));)advanceBy(context,nestedIndex-prevIndex+1),nestedIndex+4<s.length&&emitError(context,16),prevIndex=nestedIndex+1;advanceBy(context,match.index+match[0].length-prevIndex+1)}else content=context.source.slice(4),advanceBy(context,context.source.length),emitError(context,7);return{type:3,content:content,loc:getSelection(context,start)}}function parseBogusComment(context){const start=getCursor(context),contentStart="?"===context.source[1]?1:2;let content;const closeIndex=context.source.indexOf(">");return-1===closeIndex?(content=context.source.slice(contentStart),advanceBy(context,context.source.length)):(content=context.source.slice(contentStart,closeIndex),advanceBy(context,closeIndex+1)),{type:3,content:content,loc:getSelection(context,start)}}function parseElement(context,ancestors){const wasInPre=context.inPre,wasInVPre=context.inVPre,parent=last(ancestors),element=parseTag(context,0,parent),isPreBoundary=context.inPre&&!wasInPre,isVPreBoundary=context.inVPre&&!wasInVPre;if(element.isSelfClosing||context.options.isVoidTag(element.tag))return element;ancestors.push(element);const mode=context.options.getTextMode(element,parent),children=parseChildren(context,mode,ancestors);if(ancestors.pop(),element.children=children,startsWithEndTagOpen(context.source,element.tag))parseTag(context,1,parent);else if(emitError(context,24,0,element.loc.start),0===context.source.length&&"script"===element.tag.toLowerCase()){const first=children[0];first&&startsWith(first.loc.source,"\x3c!--")&&emitError(context,8)}return element.loc=getSelection(context,element.loc.start),isPreBoundary&&(context.inPre=!1),isVPreBoundary&&(context.inVPre=!1),element}const isSpecialTemplateDirective=makeMap("if,else,else-if,for,slot");function parseTag(context,type,parent){const start=getCursor(context),match=/^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source),tag=match[1],ns=context.options.getNamespace(tag,parent);advanceBy(context,match[0].length),advanceSpaces(context);const cursor=getCursor(context),currentSource=context.source;let props=parseAttributes(context,type);context.options.isPreTag(tag)&&(context.inPre=!0),!context.inVPre&&props.some(p=>7===p.type&&"pre"===p.name)&&(context.inVPre=!0,extend(context,cursor),context.source=currentSource,props=parseAttributes(context,type).filter(p=>"v-pre"!==p.name));let isSelfClosing=!1;0===context.source.length?emitError(context,9):(isSelfClosing=startsWith(context.source,"/>"),1===type&&isSelfClosing&&emitError(context,4),advanceBy(context,isSelfClosing?2:1));let tagType=0;const options=context.options;if(!context.inVPre&&!options.isCustomElement(tag)){const hasVIs=props.some(p=>7===p.type&&"is"===p.name);options.isNativeTag&&!hasVIs?options.isNativeTag(tag)||(tagType=1):(hasVIs||isCoreComponent(tag)||options.isBuiltInComponent&&options.isBuiltInComponent(tag)||/^[A-Z]/.test(tag)||"component"===tag)&&(tagType=1),"slot"===tag?tagType=2:"template"===tag&&props.some(p=>7===p.type&&isSpecialTemplateDirective(p.name))&&(tagType=3)}return{type:1,ns:ns,tag:tag,tagType:tagType,props:props,isSelfClosing:isSelfClosing,children:[],loc:getSelection(context,start),codegenNode:void 0}}function parseAttributes(context,type){const props=[],attributeNames=new Set;for(;context.source.length>0&&!startsWith(context.source,">")&&!startsWith(context.source,"/>");){if(startsWith(context.source,"/")){emitError(context,22),advanceBy(context,1),advanceSpaces(context);continue}1===type&&emitError(context,3);const attr=parseAttribute(context,attributeNames);0===type&&props.push(attr),/^[^\t\r\n\f />]/.test(context.source)&&emitError(context,15),advanceSpaces(context)}return props}function parseAttribute(context,nameSet){const start=getCursor(context),match=/^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source),name=match[0];nameSet.has(name)&&emitError(context,2),nameSet.add(name),"="===name[0]&&emitError(context,19);{const pattern=/["'<]/g;let m;for(;m=pattern.exec(name);)emitError(context,17,m.index)}advanceBy(context,name.length);let value=void 0;/^[\t\r\n\f ]*=/.test(context.source)&&(advanceSpaces(context),advanceBy(context,1),advanceSpaces(context),value=parseAttributeValue(context),value||emitError(context,13));const loc=getSelection(context,start);if(!context.inVPre&&/^(v-|:|@|#)/.test(name)){const match=/(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name),dirName=match[1]||(startsWith(name,":")?"bind":startsWith(name,"@")?"on":"slot");let arg;if(match[2]){const isSlot="slot"===dirName,startOffset=name.indexOf(match[2]),loc=getSelection(context,getNewPosition(context,start,startOffset),getNewPosition(context,start,startOffset+match[2].length+(isSlot&&match[3]||"").length));let content=match[2],isStatic=!0;content.startsWith("[")?(isStatic=!1,content.endsWith("]")||emitError(context,26),content=content.substr(1,content.length-2)):isSlot&&(content+=match[3]||""),arg={type:4,content:content,isStatic:isStatic,isConstant:isStatic,loc:loc}}if(value&&value.isQuoted){const valueLoc=value.loc;valueLoc.start.offset++,valueLoc.start.column++,valueLoc.end=advancePositionWithClone(valueLoc.start,value.content),valueLoc.source=valueLoc.source.slice(1,-1)}return{type:7,name:dirName,exp:value&&{type:4,content:value.content,isStatic:!1,isConstant:!1,loc:value.loc},arg:arg,modifiers:match[3]?match[3].substr(1).split("."):[],loc:loc}}return{type:6,name:name,value:value&&{type:2,content:value.content,loc:value.loc},loc:loc}}function parseAttributeValue(context){const start=getCursor(context);let content;const quote=context.source[0],isQuoted='"'===quote||"'"===quote;if(isQuoted){advanceBy(context,1);const endIndex=context.source.indexOf(quote);-1===endIndex?content=parseTextData(context,context.source.length,4):(content=parseTextData(context,endIndex,4),advanceBy(context,1))}else{const match=/^[^\t\r\n\f >]+/.exec(context.source);if(!match)return;const unexpectedChars=/["'<=`]/g;let m;for(;m=unexpectedChars.exec(match[0]);)emitError(context,18,m.index);content=parseTextData(context,match[0].length,4)}return{content:content,isQuoted:isQuoted,loc:getSelection(context,start)}}function parseInterpolation(context,mode){const[open,close]=context.options.delimiters,closeIndex=context.source.indexOf(close,open.length);if(-1===closeIndex)return void emitError(context,25);const start=getCursor(context);advanceBy(context,open.length);const innerStart=getCursor(context),innerEnd=getCursor(context),rawContentLength=closeIndex-open.length,rawContent=context.source.slice(0,rawContentLength),preTrimContent=parseTextData(context,rawContentLength,mode),content=preTrimContent.trim(),startOffset=preTrimContent.indexOf(content);startOffset>0&&advancePositionWithMutation(innerStart,rawContent,startOffset);const endOffset=rawContentLength-(preTrimContent.length-content.length-startOffset);return advancePositionWithMutation(innerEnd,rawContent,endOffset),advanceBy(context,close.length),{type:5,content:{type:4,isStatic:!1,isConstant:!1,content:content,loc:getSelection(context,innerStart,innerEnd)},loc:getSelection(context,start)}}function parseText(context,mode){const endTokens=["<",context.options.delimiters[0]];3===mode&&endTokens.push("]]>");let endIndex=context.source.length;for(let i=0;i<endTokens.length;i++){const index=context.source.indexOf(endTokens[i],1);-1!==index&&endIndex>index&&(endIndex=index)}const start=getCursor(context),content=parseTextData(context,endIndex,mode);return{type:2,content:content,loc:getSelection(context,start)}}function parseTextData(context,length,mode){const rawText=context.source.slice(0,length);return advanceBy(context,length),2===mode||3===mode||-1===rawText.indexOf("&")?rawText:context.options.decodeEntities(rawText,4===mode)}function getCursor(context){const{column:column,line:line,offset:offset}=context;return{column:column,line:line,offset:offset}}function getSelection(context,start,end){return{start:start,end:end=end||getCursor(context),source:context.originalSource.slice(start.offset,end.offset)}}function last(xs){return xs[xs.length-1]}function startsWith(source,searchString){return source.startsWith(searchString)}function advanceBy(context,numberOfCharacters){const{source:source}=context;advancePositionWithMutation(context,source,numberOfCharacters),context.source=source.slice(numberOfCharacters)}function advanceSpaces(context){const match=/^[\t\r\n\f ]+/.exec(context.source);match&&advanceBy(context,match[0].length)}function getNewPosition(context,start,numberOfCharacters){return advancePositionWithClone(start,context.originalSource.slice(start.offset,numberOfCharacters),numberOfCharacters)}function emitError(context,code,offset,loc=getCursor(context)){offset&&(loc.offset+=offset,loc.column+=offset),context.options.onError(createCompilerError(code,{start:loc,end:loc,source:""}))}function isEnd(context,mode,ancestors){const s=context.source;switch(mode){case 0:if(startsWith(s,"</"))for(let i=ancestors.length-1;i>=0;--i)if(startsWithEndTagOpen(s,ancestors[i].tag))return!0;break;case 1:case 2:{const parent=last(ancestors);if(parent&&startsWithEndTagOpen(s,parent.tag))return!0;break}case 3:if(startsWith(s,"]]>"))return!0}return!s}function startsWithEndTagOpen(source,tag){return startsWith(source,"</")&&source.substr(2,tag.length).toLowerCase()===tag.toLowerCase()&&/[\t\r\n\f />]/.test(source[2+tag.length]||">")}function hoistStatic(root,context){walk(root,context,new Map,isSingleElementRoot(root,root.children[0]))}function isSingleElementRoot(root,child){const{children:children}=root;return 1===children.length&&1===child.type&&!isSlotOutlet(child)}function walk(node,context,resultCache,doNotHoistNode=!1){let hasHoistedNode=!1,hasRuntimeConstant=!1;const{children:children}=node;for(let i=0;i<children.length;i++){const child=children[i];if(1===child.type&&0===child.tagType){let staticType;if(!doNotHoistNode&&(staticType=getStaticType(child,resultCache))>0){2===staticType&&(hasRuntimeConstant=!0),child.codegenNode.patchFlag="-1 /* HOISTED */",child.codegenNode=context.hoist(child.codegenNode),hasHoistedNode=!0;continue}{const codegenNode=child.codegenNode;if(13===codegenNode.type){const flag=getPatchFlag(codegenNode);if(!(flag&&512!==flag&&1!==flag||hasNonHoistableProps(child))){const props=getNodeProps(child);props&&(codegenNode.props=context.hoist(props))}}}}else if(12===child.type){const staticType=getStaticType(child.content,resultCache);staticType>0&&(2===staticType&&(hasRuntimeConstant=!0),child.codegenNode=context.hoist(child.codegenNode),hasHoistedNode=!0)}if(1===child.type)walk(child,context,resultCache);else if(11===child.type)walk(child,context,resultCache,1===child.children.length);else if(9===child.type)for(let i=0;i<child.branches.length;i++)walk(child.branches[i],context,resultCache,1===child.branches[i].children.length)}!hasRuntimeConstant&&hasHoistedNode&&context.transformHoist&&context.transformHoist(children,context,node)}function getStaticType(node,resultCache=new Map){switch(node.type){case 1:if(0!==node.tagType)return 0;const cached=resultCache.get(node);if(void 0!==cached)return cached;const codegenNode=node.codegenNode;if(13!==codegenNode.type)return 0;const flag=getPatchFlag(codegenNode);if(flag||hasNonHoistableProps(node))return resultCache.set(node,0),0;{let returnType=1;for(let i=0;i<node.children.length;i++){const childType=getStaticType(node.children[i],resultCache);if(0===childType)return resultCache.set(node,0),0;2===childType&&(returnType=2)}if(2!==returnType)for(let i=0;i<node.props.length;i++){const p=node.props[i];7===p.type&&"bind"===p.name&&p.exp&&(8===p.exp.type||p.exp.isRuntimeConstant)&&(returnType=2)}return codegenNode.isBlock&&(codegenNode.isBlock=!1),resultCache.set(node,returnType),returnType}case 2:case 3:return 1;case 9:case 11:case 10:return 0;case 5:case 12:return getStaticType(node.content,resultCache);case 4:return node.isConstant?node.isRuntimeConstant?2:1:0;case 8:let returnType=1;for(let i=0;i<node.children.length;i++){const child=node.children[i];if(isString(child)||isSymbol(child))continue;const childType=getStaticType(child,resultCache);if(0===childType)return 0;2===childType&&(returnType=2)}return returnType;default:return 0}}function hasNonHoistableProps(node){const props=getNodeProps(node);if(props&&15===props.type){const{properties:properties}=props;for(let i=0;i<properties.length;i++){const{key:key,value:value}=properties[i];if(4!==key.type||!key.isStatic||4!==value.type||!value.isStatic&&!value.isConstant)return!0}}return!1}function getNodeProps(node){const codegenNode=node.codegenNode;if(13===codegenNode.type)return codegenNode.props}function getPatchFlag(node){const flag=node.patchFlag;return flag?parseInt(flag,10):void 0}function createTransformContext(root,{prefixIdentifiers:prefixIdentifiers=!1,hoistStatic:hoistStatic=!1,cacheHandlers:cacheHandlers=!1,nodeTransforms:nodeTransforms=[],directiveTransforms:directiveTransforms={},transformHoist:transformHoist=null,isBuiltInComponent:isBuiltInComponent=NOOP,isCustomElement:isCustomElement=NOOP,expressionPlugins:expressionPlugins=[],scopeId:scopeId=null,ssr:ssr=!1,ssrCssVars:ssrCssVars="",bindingMetadata:bindingMetadata={},onError:onError=defaultOnError}){const context={prefixIdentifiers:prefixIdentifiers,hoistStatic:hoistStatic,cacheHandlers:cacheHandlers,nodeTransforms:nodeTransforms,directiveTransforms:directiveTransforms,transformHoist:transformHoist,isBuiltInComponent:isBuiltInComponent,isCustomElement:isCustomElement,expressionPlugins:expressionPlugins,scopeId:scopeId,ssr:ssr,ssrCssVars:ssrCssVars,bindingMetadata:bindingMetadata,onError:onError,root:root,helpers:new Set,components:new Set,directives:new Set,hoists:[],imports:new Set,temps:0,cached:0,identifiers:Object.create(null),scopes:{vFor:0,vSlot:0,vPre:0,vOnce:0},parent:null,currentNode:root,childIndex:0,helper:name=>(context.helpers.add(name),name),helperString:name=>`_${helperNameMap[context.helper(name)]}`,replaceNode(node){if(!context.currentNode)throw new Error("Node being replaced is already removed.");if(!context.parent)throw new Error("Cannot replace root node.");context.parent.children[context.childIndex]=context.currentNode=node},removeNode(node){if(!context.parent)throw new Error("Cannot remove root node.");const list=context.parent.children,removalIndex=node?list.indexOf(node):context.currentNode?context.childIndex:-1;if(removalIndex<0)throw new Error("node being removed is not a child of current parent");node&&node!==context.currentNode?context.childIndex>removalIndex&&(context.childIndex--,context.onNodeRemoved()):(context.currentNode=null,context.onNodeRemoved()),context.parent.children.splice(removalIndex,1)},onNodeRemoved:()=>{},addIdentifiers(exp){},removeIdentifiers(exp){},hoist(exp){context.hoists.push(exp);const identifier=createSimpleExpression(`_hoisted_${context.hoists.length}`,!1,exp.loc,!0);return identifier.hoisted=exp,identifier},cache:(exp,isVNode=!1)=>createCacheExpression(++context.cached,exp,isVNode)};return context}function transform(root,options){const context=createTransformContext(root,options);traverseNode(root,context),options.hoistStatic&&hoistStatic(root,context),options.ssr||createRootCodegen(root,context),root.helpers=[...context.helpers],root.components=[...context.components],root.directives=[...context.directives],root.imports=[...context.imports],root.hoists=context.hoists,root.temps=context.temps,root.cached=context.cached}function createRootCodegen(root,context){const{helper:helper}=context,{children:children}=root;if(1===children.length){const child=children[0];if(isSingleElementRoot(root,child)&&child.codegenNode){const codegenNode=child.codegenNode;13===codegenNode.type&&(codegenNode.isBlock=!0,helper(OPEN_BLOCK),helper(CREATE_BLOCK)),root.codegenNode=codegenNode}else root.codegenNode=child}else children.length>1&&(root.codegenNode=createVNodeCall(context,helper(FRAGMENT),void 0,root.children,`64 /* ${PatchFlagNames[64]} */`,void 0,void 0,!0))}function traverseChildren(parent,context){let i=0;const nodeRemoved=()=>{i--};for(;i<parent.children.length;i++){const child=parent.children[i];isString(child)||(context.parent=parent,context.childIndex=i,context.onNodeRemoved=nodeRemoved,traverseNode(child,context))}}function traverseNode(node,context){context.currentNode=node;const{nodeTransforms:nodeTransforms}=context,exitFns=[];for(let i=0;i<nodeTransforms.length;i++){const onExit=nodeTransforms[i](node,context);if(onExit&&(isArray(onExit)?exitFns.push(...onExit):exitFns.push(onExit)),!context.currentNode)return;node=context.currentNode}switch(node.type){case 3:context.ssr||context.helper(CREATE_COMMENT);break;case 5:context.ssr||context.helper(TO_DISPLAY_STRING);break;case 9:for(let i=0;i<node.branches.length;i++)traverseNode(node.branches[i],context);break;case 10:case 11:case 1:case 0:traverseChildren(node,context)}context.currentNode=node;let i=exitFns.length;for(;i--;)exitFns[i]()}function createStructuralDirectiveTransform(name,fn){const matches=isString(name)?n=>n===name:n=>name.test(n);return(node,context)=>{if(1===node.type){const{props:props}=node;if(3===node.tagType&&props.some(isVSlot))return;const exitFns=[];for(let i=0;i<props.length;i++){const prop=props[i];if(7===prop.type&&matches(prop.name)){props.splice(i,1),i--;const onExit=fn(node,prop,context);onExit&&exitFns.push(onExit)}}return exitFns}}}const PURE_ANNOTATION="/*#__PURE__*/";function createCodegenContext(ast,{mode:mode="function",prefixIdentifiers:prefixIdentifiers="module"===mode,sourceMap:sourceMap=!1,filename:filename="template.vue.html",scopeId:scopeId=null,optimizeImports:optimizeImports=!1,runtimeGlobalName:runtimeGlobalName="Vue",runtimeModuleName:runtimeModuleName="vue",ssr:ssr=!1}){const context={mode:mode,prefixIdentifiers:prefixIdentifiers,sourceMap:sourceMap,filename:filename,scopeId:scopeId,optimizeImports:optimizeImports,runtimeGlobalName:runtimeGlobalName,runtimeModuleName:runtimeModuleName,ssr:ssr,source:ast.loc.source,code:"",column:1,line:1,offset:0,indentLevel:0,pure:!1,map:void 0,helper:key=>`_${helperNameMap[key]}`,push(code,node){context.code+=code},indent(){newline(++context.indentLevel)},deindent(withoutNewLine=!1){withoutNewLine?--context.indentLevel:newline(--context.indentLevel)},newline(){newline(context.indentLevel)}};function newline(n){context.push("\n"+"  ".repeat(n))}return context}function generate(ast,options={}){const context=createCodegenContext(ast,options);options.onContextCreated&&options.onContextCreated(context);const{mode:mode,push:push,prefixIdentifiers:prefixIdentifiers,indent:indent,deindent:deindent,newline:newline,scopeId:scopeId,ssr:ssr}=context,hasHelpers=ast.helpers.length>0,useWithBlock=!prefixIdentifiers&&"module"!==mode;genFunctionPreamble(ast,context);const optimizeSources=options.bindingMetadata?", $props, $setup, $data, $options":"";if(push(ssr?`function ssrRender(_ctx, _push, _parent, _attrs${optimizeSources}) {`:`function render(_ctx, _cache${optimizeSources}) {`),indent(),useWithBlock&&(push("with (_ctx) {"),indent(),hasHelpers&&(push(`const { ${ast.helpers.map(s=>`${helperNameMap[s]}: _${helperNameMap[s]}`).join(", ")} } = _Vue`),push("\n"),newline())),ast.components.length&&(genAssets(ast.components,"component",context),(ast.directives.length||ast.temps>0)&&newline()),ast.directives.length&&(genAssets(ast.directives,"directive",context),ast.temps>0&&newline()),ast.temps>0){push("let ");for(let i=0;i<ast.temps;i++)push(`${i>0?", ":""}_temp${i}`)}return(ast.components.length||ast.directives.length||ast.temps)&&(push("\n"),newline()),ssr||push("return "),ast.codegenNode?genNode(ast.codegenNode,context):push("null"),useWithBlock&&(deindent(),push("}")),deindent(),push("}"),{ast:ast,code:context.code,map:context.map?context.map.toJSON():void 0}}function genFunctionPreamble(ast,context){const{ssr:ssr,prefixIdentifiers:prefixIdentifiers,push:push,newline:newline,runtimeModuleName:runtimeModuleName,runtimeGlobalName:runtimeGlobalName}=context,VueBinding=runtimeGlobalName,aliasHelper=s=>`${helperNameMap[s]}: _${helperNameMap[s]}`;if(ast.helpers.length>0&&(push(`const _Vue = ${VueBinding}\n`),ast.hoists.length)){const staticHelpers=[CREATE_VNODE,CREATE_COMMENT,CREATE_TEXT,CREATE_STATIC].filter(helper=>ast.helpers.includes(helper)).map(aliasHelper).join(", ");push(`const { ${staticHelpers} } = _Vue\n`)}genHoists(ast.hoists,context),newline(),push("return ")}function genAssets(assets,type,{helper:helper,push:push,newline:newline}){const resolver=helper("component"===type?RESOLVE_COMPONENT:RESOLVE_DIRECTIVE);for(let i=0;i<assets.length;i++){const id=assets[i];push(`const ${toValidAssetId(id,type)} = ${resolver}(${JSON.stringify(id)})`),i<assets.length-1&&newline()}}function genHoists(hoists,context){if(!hoists.length)return;context.pure=!0;const{push:push,newline:newline,helper:helper,scopeId:scopeId,mode:mode}=context;newline(),hoists.forEach((exp,i)=>{exp&&(push(`const _hoisted_${i+1} = `),genNode(exp,context),newline())}),context.pure=!1}function isText$1(n){return isString(n)||4===n.type||2===n.type||5===n.type||8===n.type}function genNodeListAsArray(nodes,context){const multilines=nodes.length>3||nodes.some(n=>isArray(n)||!isText$1(n));context.push("["),multilines&&context.indent(),genNodeList(nodes,context,multilines),multilines&&context.deindent(),context.push("]")}function genNodeList(nodes,context,multilines=!1,comma=!0){const{push:push,newline:newline}=context;for(let i=0;i<nodes.length;i++){const node=nodes[i];isString(node)?push(node):isArray(node)?genNodeListAsArray(node,context):genNode(node,context),i<nodes.length-1&&(multilines?(comma&&push(","),newline()):comma&&push(", "))}}function genNode(node,context){if(isString(node))context.push(node);else if(isSymbol(node))context.push(context.helper(node));else switch(node.type){case 1:case 9:case 11:assert(null!=node.codegenNode,"Codegen node is missing for element/if/for node. Apply appropriate transforms first."),genNode(node.codegenNode,context);break;case 2:genText(node,context);break;case 4:genExpression(node,context);break;case 5:genInterpolation(node,context);break;case 12:genNode(node.codegenNode,context);break;case 8:genCompoundExpression(node,context);break;case 3:genComment(node,context);break;case 13:genVNodeCall(node,context);break;case 14:genCallExpression(node,context);break;case 15:genObjectExpression(node,context);break;case 17:genArrayExpression(node,context);break;case 18:genFunctionExpression(node,context);break;case 19:genConditionalExpression(node,context);break;case 20:genCacheExpression(node,context);break;case 21:case 22:case 23:case 24:case 25:case 26:case 10:break;default:{assert(!1,`unhandled codegen node type: ${node.type}`);const exhaustiveCheck=node;return exhaustiveCheck}}}function genText(node,context){context.push(JSON.stringify(node.content),node)}function genExpression(node,context){const{content:content,isStatic:isStatic}=node;context.push(isStatic?JSON.stringify(content):content,node)}function genInterpolation(node,context){const{push:push,helper:helper,pure:pure}=context;pure&&push("/*#__PURE__*/"),push(`${helper(TO_DISPLAY_STRING)}(`),genNode(node.content,context),push(")")}function genCompoundExpression(node,context){for(let i=0;i<node.children.length;i++){const child=node.children[i];isString(child)?context.push(child):genNode(child,context)}}function genExpressionAsPropertyKey(node,context){const{push:push}=context;if(8===node.type)push("["),genCompoundExpression(node,context),push("]");else if(node.isStatic){const text=isSimpleIdentifier(node.content)?node.content:JSON.stringify(node.content);push(text,node)}else push(`[${node.content}]`,node)}function genComment(node,context){{const{push:push,helper:helper,pure:pure}=context;pure&&push("/*#__PURE__*/"),push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,node)}}function genVNodeCall(node,context){const{push:push,helper:helper,pure:pure}=context,{tag:tag,props:props,children:children,patchFlag:patchFlag,dynamicProps:dynamicProps,directives:directives,isBlock:isBlock,disableTracking:disableTracking}=node;directives&&push(helper(WITH_DIRECTIVES)+"("),isBlock&&push(`(${helper(OPEN_BLOCK)}(${disableTracking?"true":""}), `),pure&&push("/*#__PURE__*/"),push(helper(isBlock?CREATE_BLOCK:CREATE_VNODE)+"(",node),genNodeList(genNullableArgs([tag,props,children,patchFlag,dynamicProps]),context),push(")"),isBlock&&push(")"),directives&&(push(", "),genNode(directives,context),push(")"))}function genNullableArgs(args){let i=args.length;for(;i--&&null==args[i];);return args.slice(0,i+1).map(arg=>arg||"null")}function genCallExpression(node,context){const{push:push,helper:helper,pure:pure}=context,callee=isString(node.callee)?node.callee:helper(node.callee);pure&&push("/*#__PURE__*/"),push(callee+"(",node),genNodeList(node.arguments,context),push(")")}function genObjectExpression(node,context){const{push:push,indent:indent,deindent:deindent,newline:newline}=context,{properties:properties}=node;if(!properties.length)return void push("{}",node);const multilines=properties.length>1||properties.some(p=>4!==p.value.type);push(multilines?"{":"{ "),multilines&&indent();for(let i=0;i<properties.length;i++){const{key:key,value:value}=properties[i];genExpressionAsPropertyKey(key,context),push(": "),genNode(value,context),i<properties.length-1&&(push(","),newline())}multilines&&deindent(),push(multilines?"}":" }")}function genArrayExpression(node,context){genNodeListAsArray(node.elements,context)}function genFunctionExpression(node,context){const{push:push,indent:indent,deindent:deindent,scopeId:scopeId,mode:mode}=context,{params:params,returns:returns,body:body,newline:newline,isSlot:isSlot}=node;isSlot&&push(`_${helperNameMap[WITH_CTX]}(`),push("(",node),isArray(params)?genNodeList(params,context):params&&genNode(params,context),push(") => "),(newline||body)&&(push("{"),indent()),returns?(newline&&push("return "),isArray(returns)?genNodeListAsArray(returns,context):genNode(returns,context)):body&&genNode(body,context),(newline||body)&&(deindent(),push("}")),isSlot&&push(")")}function genConditionalExpression(node,context){const{test:test,consequent:consequent,alternate:alternate,newline:needNewline}=node,{push:push,indent:indent,deindent:deindent,newline:newline}=context;if(4===test.type){const needsParens=!isSimpleIdentifier(test.content);needsParens&&push("("),genExpression(test,context),needsParens&&push(")")}else push("("),genNode(test,context),push(")");needNewline&&indent(),context.indentLevel++,needNewline||push(" "),push("? "),genNode(consequent,context),context.indentLevel--,needNewline&&newline(),needNewline||push(" "),push(": ");const isNested=19===alternate.type;isNested||context.indentLevel++,genNode(alternate,context),isNested||context.indentLevel--,needNewline&&deindent(!0)}function genCacheExpression(node,context){const{push:push,helper:helper,indent:indent,deindent:deindent,newline:newline}=context;push(`_cache[${node.index}] || (`),node.isVNode&&(indent(),push(`${helper(SET_BLOCK_TRACKING)}(-1),`),newline()),push(`_cache[${node.index}] = `),genNode(node.value,context),node.isVNode&&(push(","),newline(),push(`${helper(SET_BLOCK_TRACKING)}(1),`),newline(),push(`_cache[${node.index}]`),deindent()),push(")")}const prohibitedKeywordRE=new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b")+"\\b"),stripStringRE=/'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;function validateBrowserExpression(node,context,asParams=!1,asRawStatements=!1){const exp=node.content;if(exp.trim())try{new Function(asRawStatements?` ${exp} `:`return ${asParams?`(${exp}) => {}`:`(${exp})`}`)}catch(e){let message=e.message;const keywordMatch=exp.replace(stripStringRE,"").match(prohibitedKeywordRE);keywordMatch&&(message=`avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`),context.onError(createCompilerError(43,node.loc,void 0,message))}}const transformExpression=(node,context)=>{if(5===node.type)node.content=processExpression(node.content,context);else if(1===node.type)for(let i=0;i<node.props.length;i++){const dir=node.props[i];if(7===dir.type&&"for"!==dir.name){const exp=dir.exp,arg=dir.arg;!exp||4!==exp.type||"on"===dir.name&&arg||(dir.exp=processExpression(exp,context,"slot"===dir.name)),arg&&4===arg.type&&!arg.isStatic&&(dir.arg=processExpression(arg,context))}}};function processExpression(node,context,asParams=!1,asRawStatements=!1){return validateBrowserExpression(node,context,asParams,asRawStatements),node}const transformIf=createStructuralDirectiveTransform(/^(if|else|else-if)$/,(node,dir,context)=>processIf(node,dir,context,(ifNode,branch,isRoot)=>{const siblings=context.parent.children;let i=siblings.indexOf(ifNode),key=0;for(;i-- >=0;){const sibling=siblings[i];sibling&&9===sibling.type&&(key+=sibling.branches.length)}return()=>{if(isRoot)ifNode.codegenNode=createCodegenNodeForBranch(branch,key,context);else{let parentCondition=ifNode.codegenNode;for(;19===parentCondition.alternate.type;)parentCondition=parentCondition.alternate;parentCondition.alternate=createCodegenNodeForBranch(branch,key+ifNode.branches.length-1,context)}}}));function processIf(node,dir,context,processCodegen){if(!("else"===dir.name||dir.exp&&dir.exp.content.trim())){const loc=dir.exp?dir.exp.loc:node.loc;context.onError(createCompilerError(27,dir.loc)),dir.exp=createSimpleExpression("true",!1,loc)}if(dir.exp&&validateBrowserExpression(dir.exp,context),"if"===dir.name){const branch=createIfBranch(node,dir),ifNode={type:9,loc:node.loc,branches:[branch]};if(context.replaceNode(ifNode),processCodegen)return processCodegen(ifNode,branch,!0)}else{const siblings=context.parent.children,comments=[];let i=siblings.indexOf(node);for(;i-- >=-1;){const sibling=siblings[i];if(!sibling||3!==sibling.type){if(sibling&&9===sibling.type){context.removeNode();const branch=createIfBranch(node,dir);comments.length&&(branch.children=[...comments,...branch.children]);{const key=branch.userKey;key&&sibling.branches.forEach(({userKey:userKey})=>{isSameKey(userKey,key)&&context.onError(createCompilerError(28,branch.userKey.loc))})}sibling.branches.push(branch);const onExit=processCodegen&&processCodegen(sibling,branch,!1);traverseNode(branch,context),onExit&&onExit(),context.currentNode=null}else context.onError(createCompilerError(29,node.loc));break}context.removeNode(sibling),comments.unshift(sibling)}}}function createIfBranch(node,dir){return{type:10,loc:node.loc,condition:"else"===dir.name?void 0:dir.exp,children:3!==node.tagType||findDir(node,"for")?[node]:node.children,userKey:findProp(node,"key")}}function createCodegenNodeForBranch(branch,keyIndex,context){return branch.condition?createConditionalExpression(branch.condition,createChildrenCodegenNode(branch,keyIndex,context),createCallExpression(context.helper(CREATE_COMMENT),['"v-if"',"true"])):createChildrenCodegenNode(branch,keyIndex,context)}function createChildrenCodegenNode(branch,keyIndex,context){const{helper:helper}=context,keyProperty=createObjectProperty("key",createSimpleExpression(`${keyIndex}`,!1,locStub,!0)),{children:children}=branch,firstChild=children[0],needFragmentWrapper=1!==children.length||1!==firstChild.type;if(needFragmentWrapper){if(1===children.length&&11===firstChild.type){const vnodeCall=firstChild.codegenNode;return injectProp(vnodeCall,keyProperty,context),vnodeCall}return createVNodeCall(context,helper(FRAGMENT),createObjectExpression([keyProperty]),children,`64 /* ${PatchFlagNames[64]} */`,void 0,void 0,!0,!1,branch.loc)}{const vnodeCall=firstChild.codegenNode;return 13===vnodeCall.type&&(vnodeCall.isBlock=!0,helper(OPEN_BLOCK),helper(CREATE_BLOCK)),injectProp(vnodeCall,keyProperty,context),vnodeCall}}function isSameKey(a,b){if(!a||a.type!==b.type)return!1;if(6===a.type){if(a.value.content!==b.value.content)return!1}else{const exp=a.exp,branchExp=b.exp;if(exp.type!==branchExp.type)return!1;if(4!==exp.type||exp.isStatic!==branchExp.isStatic||exp.content!==branchExp.content)return!1}return!0}const transformFor=createStructuralDirectiveTransform("for",(node,dir,context)=>{const{helper:helper}=context;return processFor(node,dir,context,forNode=>{const renderExp=createCallExpression(helper(RENDER_LIST),[forNode.source]),keyProp=findProp(node,"key"),keyProperty=keyProp?createObjectProperty("key",6===keyProp.type?createSimpleExpression(keyProp.value.content,!0):keyProp.exp):null,isStableFragment=4===forNode.source.type&&forNode.source.isConstant,fragmentFlag=isStableFragment?64:keyProp?128:256;return forNode.codegenNode=createVNodeCall(context,helper(FRAGMENT),void 0,renderExp,`${fragmentFlag} /* ${PatchFlagNames[fragmentFlag]} */`,void 0,void 0,!0,!isStableFragment,node.loc),()=>{let childBlock;const isTemplate=isTemplateNode(node),{children:children}=forNode;isTemplate&&node.children.some(c=>{if(1===c.type){const key=findProp(c,"key");if(key)return context.onError(createCompilerError(32,key.loc)),!0}});const needFragmentWrapper=1!==children.length||1!==children[0].type,slotOutlet=isSlotOutlet(node)?node:isTemplate&&1===node.children.length&&isSlotOutlet(node.children[0])?node.children[0]:null;slotOutlet?(childBlock=slotOutlet.codegenNode,isTemplate&&keyProperty&&injectProp(childBlock,keyProperty,context)):needFragmentWrapper?childBlock=createVNodeCall(context,helper(FRAGMENT),keyProperty?createObjectExpression([keyProperty]):void 0,node.children,`64 /* ${PatchFlagNames[64]} */`,void 0,void 0,!0):(childBlock=children[0].codegenNode,isTemplate&&keyProperty&&injectProp(childBlock,keyProperty,context),childBlock.isBlock=!isStableFragment,childBlock.isBlock&&(helper(OPEN_BLOCK),helper(CREATE_BLOCK))),renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult),childBlock,!0))}})});function processFor(node,dir,context,processCodegen){if(!dir.exp)return void context.onError(createCompilerError(30,dir.loc));const parseResult=parseForExpression(dir.exp,context);if(!parseResult)return void context.onError(createCompilerError(31,dir.loc));const{addIdentifiers:addIdentifiers,removeIdentifiers:removeIdentifiers,scopes:scopes}=context,{source:source,value:value,key:key,index:index}=parseResult,forNode={type:11,loc:dir.loc,source:source,valueAlias:value,keyAlias:key,objectIndexAlias:index,parseResult:parseResult,children:isTemplateNode(node)?node.children:[node]};context.replaceNode(forNode),scopes.vFor++;const onExit=processCodegen&&processCodegen(forNode);return()=>{scopes.vFor--,onExit&&onExit()}}const forAliasRE=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,forIteratorRE=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,stripParensRE=/^\(|\)$/g;function parseForExpression(input,context){const loc=input.loc,exp=input.content,inMatch=exp.match(forAliasRE);if(!inMatch)return;const[,LHS,RHS]=inMatch,result={source:createAliasExpression(loc,RHS.trim(),exp.indexOf(RHS,LHS.length)),value:void 0,key:void 0,index:void 0};validateBrowserExpression(result.source,context);let valueContent=LHS.trim().replace(stripParensRE,"").trim();const trimmedOffset=LHS.indexOf(valueContent),iteratorMatch=valueContent.match(forIteratorRE);if(iteratorMatch){valueContent=valueContent.replace(forIteratorRE,"").trim();const keyContent=iteratorMatch[1].trim();let keyOffset;if(keyContent&&(keyOffset=exp.indexOf(keyContent,trimmedOffset+valueContent.length),result.key=createAliasExpression(loc,keyContent,keyOffset),validateBrowserExpression(result.key,context,!0)),iteratorMatch[2]){const indexContent=iteratorMatch[2].trim();indexContent&&(result.index=createAliasExpression(loc,indexContent,exp.indexOf(indexContent,result.key?keyOffset+keyContent.length:trimmedOffset+valueContent.length)),validateBrowserExpression(result.index,context,!0))}}return valueContent&&(result.value=createAliasExpression(loc,valueContent,trimmedOffset),validateBrowserExpression(result.value,context,!0)),result}function createAliasExpression(range,content,offset){return createSimpleExpression(content,!1,getInnerRange(range,offset,content.length))}function createForLoopParams({value:value,key:key,index:index}){const params=[];return value&&params.push(value),key&&(value||params.push(createSimpleExpression("_",!1)),params.push(key)),index&&(key||(value||params.push(createSimpleExpression("_",!1)),params.push(createSimpleExpression("__",!1))),params.push(index)),params}const defaultFallback=createSimpleExpression("undefined",!1),trackSlotScopes=(node,context)=>{if(1===node.type&&(1===node.tagType||3===node.tagType)){const vSlot=findDir(node,"slot");if(vSlot){const slotProps=vSlot.exp;return context.scopes.vSlot++,()=>{context.scopes.vSlot--}}}},buildClientSlotFn=(props,children,loc)=>createFunctionExpression(props,children,!1,!0,children.length?children[0].loc:loc);function buildSlots(node,context,buildSlotFn=buildClientSlotFn){context.helper(WITH_CTX);const{children:children,loc:loc}=node,slotsProperties=[],dynamicSlots=[],buildDefaultSlotProperty=(props,children)=>createObjectProperty("default",buildSlotFn(props,children,loc));let hasDynamicSlots=context.scopes.vSlot>0||context.scopes.vFor>0;const onComponentSlot=findDir(node,"slot",!0);if(onComponentSlot){const{arg:arg,exp:exp}=onComponentSlot;arg&&!isStaticExp(arg)&&(hasDynamicSlots=!0),slotsProperties.push(createObjectProperty(arg||createSimpleExpression("default",!0),buildSlotFn(exp,children,loc)))}let hasTemplateSlots=!1,hasNamedDefaultSlot=!1;const implicitDefaultChildren=[],seenSlotNames=new Set;for(let i=0;i<children.length;i++){const slotElement=children[i];let slotDir;if(!isTemplateNode(slotElement)||!(slotDir=findDir(slotElement,"slot",!0))){3!==slotElement.type&&implicitDefaultChildren.push(slotElement);continue}if(onComponentSlot){context.onError(createCompilerError(36,slotDir.loc));break}hasTemplateSlots=!0;const{children:slotChildren,loc:slotLoc}=slotElement,{arg:slotName=createSimpleExpression("default",!0),exp:slotProps,loc:dirLoc}=slotDir;let staticSlotName;isStaticExp(slotName)?staticSlotName=slotName?slotName.content:"default":hasDynamicSlots=!0;const slotFunction=buildSlotFn(slotProps,slotChildren,slotLoc);let vIf,vElse,vFor;if(vIf=findDir(slotElement,"if"))hasDynamicSlots=!0,dynamicSlots.push(createConditionalExpression(vIf.exp,buildDynamicSlot(slotName,slotFunction),defaultFallback));else if(vElse=findDir(slotElement,/^else(-if)?$/,!0)){let j=i,prev;for(;j--&&(prev=children[j],3===prev.type););if(prev&&isTemplateNode(prev)&&findDir(prev,"if")){children.splice(i,1),i--;let conditional=dynamicSlots[dynamicSlots.length-1];for(;19===conditional.alternate.type;)conditional=conditional.alternate;conditional.alternate=vElse.exp?createConditionalExpression(vElse.exp,buildDynamicSlot(slotName,slotFunction),defaultFallback):buildDynamicSlot(slotName,slotFunction)}else context.onError(createCompilerError(29,vElse.loc))}else if(vFor=findDir(slotElement,"for")){hasDynamicSlots=!0;const parseResult=vFor.parseResult||parseForExpression(vFor.exp,context);parseResult?dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST),[parseResult.source,createFunctionExpression(createForLoopParams(parseResult),buildDynamicSlot(slotName,slotFunction),!0)])):context.onError(createCompilerError(31,vFor.loc))}else{if(staticSlotName){if(seenSlotNames.has(staticSlotName)){context.onError(createCompilerError(37,dirLoc));continue}seenSlotNames.add(staticSlotName),"default"===staticSlotName&&(hasNamedDefaultSlot=!0)}slotsProperties.push(createObjectProperty(slotName,slotFunction))}}onComponentSlot||(hasTemplateSlots?implicitDefaultChildren.length&&(hasNamedDefaultSlot?context.onError(createCompilerError(38,implicitDefaultChildren[0].loc)):slotsProperties.push(buildDefaultSlotProperty(void 0,implicitDefaultChildren))):slotsProperties.push(buildDefaultSlotProperty(void 0,children)));const slotFlag=hasDynamicSlots?2:hasForwardedSlots(node.children)?3:1;let slots=createObjectExpression(slotsProperties.concat(createObjectProperty("_",createSimpleExpression(""+slotFlag,!1))),loc);return dynamicSlots.length&&(slots=createCallExpression(context.helper(CREATE_SLOTS),[slots,createArrayExpression(dynamicSlots)])),{slots:slots,hasDynamicSlots:hasDynamicSlots}}function buildDynamicSlot(name,fn){return createObjectExpression([createObjectProperty("name",name),createObjectProperty("fn",fn)])}function hasForwardedSlots(children){for(let i=0;i<children.length;i++){const child=children[i];if(1===child.type&&(2===child.tagType||0===child.tagType&&hasForwardedSlots(child.children)))return!0}return!1}const directiveImportMap=new WeakMap,transformElement=(node,context)=>{if(1===node.type&&(0===node.tagType||1===node.tagType))return function postTransformElement(){const{tag:tag,props:props}=node,isComponent=1===node.tagType,vnodeTag=isComponent?resolveComponentType(node,context):`"${tag}"`,isDynamicComponent=isObject(vnodeTag)&&vnodeTag.callee===RESOLVE_DYNAMIC_COMPONENT;let vnodeProps,vnodeChildren,vnodePatchFlag,patchFlag=0,vnodeDynamicProps,dynamicPropNames,vnodeDirectives,shouldUseBlock=isDynamicComponent||vnodeTag===TELEPORT||vnodeTag===SUSPENSE||!isComponent&&("svg"===tag||"foreignObject"===tag||findProp(node,"key",!0));if(props.length>0){const propsBuildResult=buildProps(node,context);vnodeProps=propsBuildResult.props,patchFlag=propsBuildResult.patchFlag,dynamicPropNames=propsBuildResult.dynamicPropNames;const directives=propsBuildResult.directives;vnodeDirectives=directives&&directives.length?createArrayExpression(directives.map(dir=>buildDirectiveArgs(dir,context))):void 0}if(node.children.length>0){vnodeTag===KEEP_ALIVE&&(shouldUseBlock=!0,patchFlag|=1024,node.children.length>1&&context.onError(createCompilerError(44,{start:node.children[0].loc.start,end:node.children[node.children.length-1].loc.end,source:""})));const shouldBuildAsSlots=isComponent&&vnodeTag!==TELEPORT&&vnodeTag!==KEEP_ALIVE;if(shouldBuildAsSlots){const{slots:slots,hasDynamicSlots:hasDynamicSlots}=buildSlots(node,context);vnodeChildren=slots,hasDynamicSlots&&(patchFlag|=1024)}else if(1===node.children.length&&vnodeTag!==TELEPORT){const child=node.children[0],type=child.type,hasDynamicTextChild=5===type||8===type;hasDynamicTextChild&&!getStaticType(child)&&(patchFlag|=1),vnodeChildren=hasDynamicTextChild||2===type?child:node.children}else vnodeChildren=node.children}if(0!==patchFlag){if(patchFlag<0)vnodePatchFlag=patchFlag+` /* ${PatchFlagNames[patchFlag]} */`;else{const flagNames=Object.keys(PatchFlagNames).map(Number).filter(n=>n>0&&patchFlag&n).map(n=>PatchFlagNames[n]).join(", ");vnodePatchFlag=patchFlag+` /* ${flagNames} */`}dynamicPropNames&&dynamicPropNames.length&&(vnodeDynamicProps=stringifyDynamicPropNames(dynamicPropNames))}node.codegenNode=createVNodeCall(context,vnodeTag,vnodeProps,vnodeChildren,vnodePatchFlag,vnodeDynamicProps,vnodeDirectives,!!shouldUseBlock,!1,node.loc)}};function resolveComponentType(node,context,ssr=!1){const{tag:tag}=node,isProp="component"===node.tag?findProp(node,"is"):findDir(node,"is");if(isProp){const exp=6===isProp.type?isProp.value&&createSimpleExpression(isProp.value.content,!0):isProp.exp;if(exp)return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT),[exp])}const builtIn=isCoreComponent(tag)||context.isBuiltInComponent(tag);return builtIn?(ssr||context.helper(builtIn),builtIn):"setup"===context.bindingMetadata[tag]?`$setup[${JSON.stringify(tag)}]`:(context.helper(RESOLVE_COMPONENT),context.components.add(tag),toValidAssetId(tag,"component"))}function buildProps(node,context,props=node.props,ssr=!1){const{tag:tag,loc:elementLoc}=node,isComponent=1===node.tagType;let properties=[];const mergeArgs=[],runtimeDirectives=[];let patchFlag=0,hasRef=!1,hasClassBinding=!1,hasStyleBinding=!1,hasHydrationEventBinding=!1,hasDynamicKeys=!1,hasVnodeHook=!1;const dynamicPropNames=[],analyzePatchFlag=({key:key,value:value})=>{if(isStaticExp(key)){const name=key.content,isEventHandler=isOn(name);if(isComponent||!isEventHandler||"onclick"===name.toLowerCase()||"onUpdate:modelValue"===name||isReservedProp(name)||(hasHydrationEventBinding=!0),isEventHandler&&isReservedProp(name)&&(hasVnodeHook=!0),20===value.type||(4===value.type||8===value.type)&&getStaticType(value)>0)return;"ref"===name?hasRef=!0:"class"!==name||isComponent?"style"!==name||isComponent?"key"===name||dynamicPropNames.includes(name)||dynamicPropNames.push(name):hasStyleBinding=!0:hasClassBinding=!0}else hasDynamicKeys=!0};for(let i=0;i<props.length;i++){const prop=props[i];if(6===prop.type){const{loc:loc,name:name,value:value}=prop;if("ref"===name&&(hasRef=!0),"is"===name&&"component"===tag)continue;properties.push(createObjectProperty(createSimpleExpression(name,!0,getInnerRange(loc,0,name.length)),createSimpleExpression(value?value.content:"",!0,value?value.loc:loc)))}else{const{name:name,arg:arg,exp:exp,loc:loc}=prop,isBind="bind"===name,isOn="on"===name;if("slot"===name){isComponent||context.onError(createCompilerError(39,loc));continue}if("once"===name)continue;if("is"===name||isBind&&"component"===tag&&isBindKey(arg,"is"))continue;if(isOn&&ssr)continue;if(!arg&&(isBind||isOn)){hasDynamicKeys=!0,exp?(properties.length&&(mergeArgs.push(createObjectExpression(dedupeProperties(properties),elementLoc)),properties=[]),isBind?mergeArgs.push(exp):mergeArgs.push({type:14,loc:loc,callee:context.helper(TO_HANDLERS),arguments:[exp]})):context.onError(createCompilerError(isBind?33:34,loc));continue}const directiveTransform=context.directiveTransforms[name];if(directiveTransform){const{props:props,needRuntime:needRuntime}=directiveTransform(prop,node,context);!ssr&&props.forEach(analyzePatchFlag),properties.push(...props),needRuntime&&(runtimeDirectives.push(prop),isSymbol(needRuntime)&&directiveImportMap.set(prop,needRuntime))}else runtimeDirectives.push(prop)}}let propsExpression=void 0;return mergeArgs.length?(properties.length&&mergeArgs.push(createObjectExpression(dedupeProperties(properties),elementLoc)),propsExpression=mergeArgs.length>1?createCallExpression(context.helper(MERGE_PROPS),mergeArgs,elementLoc):mergeArgs[0]):properties.length&&(propsExpression=createObjectExpression(dedupeProperties(properties),elementLoc)),hasDynamicKeys?patchFlag|=16:(hasClassBinding&&(patchFlag|=2),hasStyleBinding&&(patchFlag|=4),dynamicPropNames.length&&(patchFlag|=8),hasHydrationEventBinding&&(patchFlag|=32)),0!==patchFlag&&32!==patchFlag||!(hasRef||hasVnodeHook||runtimeDirectives.length>0)||(patchFlag|=512),{props:propsExpression,directives:runtimeDirectives,patchFlag:patchFlag,dynamicPropNames:dynamicPropNames}}function dedupeProperties(properties){const knownProps=new Map,deduped=[];for(let i=0;i<properties.length;i++){const prop=properties[i];if(8===prop.key.type||!prop.key.isStatic){deduped.push(prop);continue}const name=prop.key.content,existing=knownProps.get(name);existing?("style"===name||"class"===name||name.startsWith("on"))&&mergeAsArray(existing,prop):(knownProps.set(name,prop),deduped.push(prop))}return deduped}function mergeAsArray(existing,incoming){17===existing.value.type?existing.value.elements.push(incoming.value):existing.value=createArrayExpression([existing.value,incoming.value],existing.loc)}function buildDirectiveArgs(dir,context){const dirArgs=[],runtime=directiveImportMap.get(dir);runtime?dirArgs.push(context.helperString(runtime)):(context.helper(RESOLVE_DIRECTIVE),context.directives.add(dir.name),dirArgs.push(toValidAssetId(dir.name,"directive")));const{loc:loc}=dir;if(dir.exp&&dirArgs.push(dir.exp),dir.arg&&(dir.exp||dirArgs.push("void 0"),dirArgs.push(dir.arg)),Object.keys(dir.modifiers).length){dir.arg||(dir.exp||dirArgs.push("void 0"),dirArgs.push("void 0"));const trueExpression=createSimpleExpression("true",!1,loc);dirArgs.push(createObjectExpression(dir.modifiers.map(modifier=>createObjectProperty(modifier,trueExpression)),loc))}return createArrayExpression(dirArgs,dir.loc)}function stringifyDynamicPropNames(props){let propsNamesString="[";for(let i=0,l=props.length;i<l;i++)propsNamesString+=JSON.stringify(props[i]),i<l-1&&(propsNamesString+=", ");return propsNamesString+"]"}const transformSlotOutlet=(node,context)=>{if(isSlotOutlet(node)){const{children:children,loc:loc}=node,{slotName:slotName,slotProps:slotProps}=processSlotOutlet(node,context),slotArgs=[context.prefixIdentifiers?"_ctx.$slots":"$slots",slotName];slotProps&&slotArgs.push(slotProps),children.length&&(slotProps||slotArgs.push("{}"),slotArgs.push(createFunctionExpression([],children,!1,!1,loc))),node.codegenNode=createCallExpression(context.helper(RENDER_SLOT),slotArgs,loc)}};function processSlotOutlet(node,context){let slotName='"default"',slotProps=void 0;const name=findProp(node,"name");name&&(6===name.type&&name.value?slotName=JSON.stringify(name.value.content):7===name.type&&name.exp&&(slotName=name.exp));const propsWithoutName=name?node.props.filter(p=>p!==name):node.props;if(propsWithoutName.length>0){const{props:props,directives:directives}=buildProps(node,context,propsWithoutName);slotProps=props,directives.length&&context.onError(createCompilerError(35,directives[0].loc))}return{slotName:slotName,slotProps:slotProps}}const fnExpRE=/^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/,transformOn=(dir,node,context,augmentor)=>{const{loc:loc,modifiers:modifiers,arg:arg}=dir;let eventName;if(dir.exp||modifiers.length||context.onError(createCompilerError(34,loc)),4===arg.type)if(arg.isStatic){const rawName=arg.content,normalizedName=rawName.startsWith("vnode")?capitalize(camelize(rawName)):capitalize(rawName);eventName=createSimpleExpression(`on${normalizedName}`,!0,arg.loc)}else eventName=createCompoundExpression([`"on" + ${context.helperString(CAPITALIZE)}(`,arg,")"]);else eventName=arg,eventName.children.unshift(`"on" + ${context.helperString(CAPITALIZE)}(`),eventName.children.push(")");let exp=dir.exp;exp&&!exp.content.trim()&&(exp=void 0);let isCacheable=context.cacheHandlers&&!exp;if(exp){const isMemberExp=isMemberExpression(exp.content),isInlineStatement=!(isMemberExp||fnExpRE.test(exp.content)),hasMultipleStatements=exp.content.includes(";");validateBrowserExpression(exp,context,!1,hasMultipleStatements),(isInlineStatement||isCacheable&&isMemberExp)&&(exp=createCompoundExpression([`${isInlineStatement?"$event":"(...args)"} => ${hasMultipleStatements?"{":"("}`,exp,hasMultipleStatements?"}":")"]))}let ret={props:[createObjectProperty(eventName,exp||createSimpleExpression("() => {}",!1,loc))]};return augmentor&&(ret=augmentor(ret)),isCacheable&&(ret.props[0].value=context.cache(ret.props[0].value)),ret},transformBind=(dir,node,context)=>{const{exp:exp,modifiers:modifiers,loc:loc}=dir,arg=dir.arg;return modifiers.includes("camel")&&(4===arg.type?arg.isStatic?arg.content=camelize(arg.content):arg.content=`${context.helperString(CAMELIZE)}(${arg.content})`:(arg.children.unshift(`${context.helperString(CAMELIZE)}(`),arg.children.push(")"))),!exp||4===exp.type&&!exp.content.trim()?(context.onError(createCompilerError(33,loc)),{props:[createObjectProperty(arg,createSimpleExpression("",!0,loc))]}):{props:[createObjectProperty(arg,exp)]}},transformText=(node,context)=>{if(0===node.type||1===node.type||11===node.type||10===node.type)return()=>{const children=node.children;let currentContainer=void 0,hasText=!1;for(let i=0;i<children.length;i++){const child=children[i];if(isText(child)){hasText=!0;for(let j=i+1;j<children.length;j++){const next=children[j];if(!isText(next)){currentContainer=void 0;break}currentContainer||(currentContainer=children[i]={type:8,loc:child.loc,children:[child]}),currentContainer.children.push(" + ",next),children.splice(j,1),j--}}}if(hasText&&(1!==children.length||0!==node.type&&(1!==node.type||0!==node.tagType)))for(let i=0;i<children.length;i++){const child=children[i];if(isText(child)||8===child.type){const callArgs=[];2===child.type&&" "===child.content||callArgs.push(child),context.ssr||2===child.type||callArgs.push(`1 /* ${PatchFlagNames[1]} */`),children[i]={type:12,content:child,loc:child.loc,codegenNode:createCallExpression(context.helper(CREATE_TEXT),callArgs)}}}}},seen=new WeakSet,transformOnce=(node,context)=>{if(1===node.type&&findDir(node,"once",!0)){if(seen.has(node))return;return seen.add(node),context.helper(SET_BLOCK_TRACKING),()=>{const cur=context.currentNode;cur.codegenNode&&(cur.codegenNode=context.cache(cur.codegenNode,!0))}}},transformModel=(dir,node,context)=>{const{exp:exp,arg:arg}=dir;if(!exp)return context.onError(createCompilerError(40,dir.loc)),createTransformProps();const expString=4===exp.type?exp.content:exp.loc.source;if(!isMemberExpression(expString))return context.onError(createCompilerError(41,exp.loc)),createTransformProps();const propName=arg||createSimpleExpression("modelValue",!0),eventName=arg?isStaticExp(arg)?`onUpdate:${arg.content}`:createCompoundExpression(['"onUpdate:" + ',arg]):"onUpdate:modelValue",props=[createObjectProperty(propName,dir.exp),createObjectProperty(eventName,createCompoundExpression(["$event => (",exp," = $event)"]))];if(dir.modifiers.length&&1===node.tagType){const modifiers=dir.modifiers.map(m=>(isSimpleIdentifier(m)?m:JSON.stringify(m))+": true").join(", "),modifiersKey=arg?isStaticExp(arg)?`${arg.content}Modifiers`:createCompoundExpression([arg,' + "Modifiers"']):"modelModifiers";props.push(createObjectProperty(modifiersKey,createSimpleExpression(`{ ${modifiers} }`,!1,dir.loc,!0)))}return createTransformProps(props)};function createTransformProps(props=[]){return{props:props}}function getBaseTransformPreset(prefixIdentifiers){return[[transformOnce,transformIf,transformFor,transformExpression,transformSlotOutlet,transformElement,trackSlotScopes,transformText],{on:transformOn,bind:transformBind,model:transformModel}]}function baseCompile(template,options={}){const onError=options.onError||defaultOnError,isModuleMode="module"===options.mode;!0===options.prefixIdentifiers?onError(createCompilerError(45)):isModuleMode&&onError(createCompilerError(46));const prefixIdentifiers=!1;options.cacheHandlers&&onError(createCompilerError(47)),options.scopeId&&!isModuleMode&&onError(createCompilerError(48));const ast=isString(template)?baseParse(template,options):template,[nodeTransforms,directiveTransforms]=getBaseTransformPreset();return transform(ast,extend({},options,{prefixIdentifiers:!1,nodeTransforms:[...nodeTransforms,...options.nodeTransforms||[]],directiveTransforms:extend({},directiveTransforms,options.directiveTransforms||{})})),generate(ast,extend({},options,{prefixIdentifiers:!1}))}const noopDirectiveTransform=()=>({props:[]}),V_MODEL_RADIO=Symbol("vModelRadio"),V_MODEL_CHECKBOX=Symbol("vModelCheckbox"),V_MODEL_TEXT=Symbol("vModelText"),V_MODEL_SELECT=Symbol("vModelSelect"),V_MODEL_DYNAMIC=Symbol("vModelDynamic"),V_ON_WITH_MODIFIERS=Symbol("vOnModifiersGuard"),V_ON_WITH_KEYS=Symbol("vOnKeysGuard"),V_SHOW=Symbol("vShow"),TRANSITION$1=Symbol("Transition"),TRANSITION_GROUP=Symbol("TransitionGroup");let decoder;function decodeHtmlBrowser(raw){return(decoder||(decoder=document.createElement("div"))).innerHTML=raw,decoder.textContent}registerRuntimeHelpers({[V_MODEL_RADIO]:"vModelRadio",[V_MODEL_CHECKBOX]:"vModelCheckbox",[V_MODEL_TEXT]:"vModelText",[V_MODEL_SELECT]:"vModelSelect",[V_MODEL_DYNAMIC]:"vModelDynamic",[V_ON_WITH_MODIFIERS]:"withModifiers",[V_ON_WITH_KEYS]:"withKeys",[V_SHOW]:"vShow",[TRANSITION$1]:"Transition",[TRANSITION_GROUP]:"TransitionGroup"});const isRawTextContainer=makeMap("style,iframe,script,noscript",!0),parserOptions={isVoidTag:isVoidTag,isNativeTag:tag=>isHTMLTag(tag)||isSVGTag(tag),isPreTag:tag=>"pre"===tag,decodeEntities:decodeHtmlBrowser,isBuiltInComponent:tag=>isBuiltInType(tag,"Transition")?TRANSITION$1:isBuiltInType(tag,"TransitionGroup")?TRANSITION_GROUP:void 0,getNamespace(tag,parent){let ns=parent?parent.ns:0;if(parent&&2===ns)if("annotation-xml"===parent.tag){if("svg"===tag)return 1;parent.props.some(a=>6===a.type&&"encoding"===a.name&&null!=a.value&&("text/html"===a.value.content||"application/xhtml+xml"===a.value.content))&&(ns=0)}else/^m(?:[ions]|text)$/.test(parent.tag)&&"mglyph"!==tag&&"malignmark"!==tag&&(ns=0);else parent&&1===ns&&("foreignObject"!==parent.tag&&"desc"!==parent.tag&&"title"!==parent.tag||(ns=0));if(0===ns){if("svg"===tag)return 1;if("math"===tag)return 2}return ns},getTextMode({tag:tag,ns:ns}){if(0===ns){if("textarea"===tag||"title"===tag)return 1;if(isRawTextContainer(tag))return 2}return 0}},transformStyle=node=>{1===node.type&&node.props.forEach((p,i)=>{6===p.type&&"style"===p.name&&p.value&&(node.props[i]={type:7,name:"bind",arg:createSimpleExpression("style",!0,p.loc),exp:parseInlineCSS(p.value.content,p.loc),modifiers:[],loc:p.loc})})},parseInlineCSS=(cssText,loc)=>{const normalized=parseStringStyle(cssText);return createSimpleExpression(JSON.stringify(normalized),!1,loc,!0)};function createDOMCompilerError(code,loc){return createCompilerError(code,loc,DOMErrorMessages)}const DOMErrorMessages={49:"v-html is missing expression.",50:"v-html will override element children.",51:"v-text is missing expression.",52:"v-text will override element children.",53:"v-model can only be used on <input>, <textarea> and <select> elements.",54:"v-model argument is not supported on plain elements.",55:"v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",56:"Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",57:"v-show is missing expression.",58:"<Transition> expects exactly one child element or component.",59:"Tags with side effect (<script> and <style>) are ignored in client component templates."},transformVHtml=(dir,node,context)=>{const{exp:exp,loc:loc}=dir;return exp||context.onError(createDOMCompilerError(49,loc)),node.children.length&&(context.onError(createDOMCompilerError(50,loc)),node.children.length=0),{props:[createObjectProperty(createSimpleExpression("innerHTML",!0,loc),exp||createSimpleExpression("",!0))]}},transformVText=(dir,node,context)=>{const{exp:exp,loc:loc}=dir;return exp||context.onError(createDOMCompilerError(51,loc)),node.children.length&&(context.onError(createDOMCompilerError(52,loc)),node.children.length=0),{props:[createObjectProperty(createSimpleExpression("textContent",!0,loc),exp||createSimpleExpression("",!0))]}},transformModel$1=(dir,node,context)=>{const baseResult=transformModel(dir,node,context);if(!baseResult.props.length||1===node.tagType)return baseResult;function checkDuplicatedValue(){const value=findProp(node,"value");value&&context.onError(createDOMCompilerError(56,value.loc))}dir.arg&&context.onError(createDOMCompilerError(54,dir.arg.loc));const{tag:tag}=node,isCustomElement=context.isCustomElement(tag);if("input"===tag||"textarea"===tag||"select"===tag||isCustomElement){let directiveToUse=V_MODEL_TEXT,isInvalidType=!1;if("input"===tag||isCustomElement){const type=findProp(node,"type");if(type){if(7===type.type)directiveToUse=V_MODEL_DYNAMIC;else if(type.value)switch(type.value.content){case"radio":directiveToUse=V_MODEL_RADIO;break;case"checkbox":directiveToUse=V_MODEL_CHECKBOX;break;case"file":isInvalidType=!0,context.onError(createDOMCompilerError(55,dir.loc));break;default:checkDuplicatedValue()}}else hasDynamicKeyVBind(node)?directiveToUse=V_MODEL_DYNAMIC:checkDuplicatedValue()}else"select"===tag?directiveToUse=V_MODEL_SELECT:checkDuplicatedValue();isInvalidType||(baseResult.needRuntime=context.helper(directiveToUse))}else context.onError(createDOMCompilerError(53,dir.loc));return baseResult.props=baseResult.props.filter(p=>!(4===p.key.type&&"modelValue"===p.key.content)),baseResult},isEventOptionModifier=makeMap("passive,once,capture"),isNonKeyModifier=makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"),maybeKeyModifier=makeMap("left,right"),isKeyboardEvent=makeMap("onkeyup,onkeydown,onkeypress",!0),resolveModifiers=(key,modifiers)=>{const keyModifiers=[],nonKeyModifiers=[],eventOptionModifiers=[];for(let i=0;i<modifiers.length;i++){const modifier=modifiers[i];isEventOptionModifier(modifier)?eventOptionModifiers.push(modifier):maybeKeyModifier(modifier)?isStaticExp(key)?isKeyboardEvent(key.content)?keyModifiers.push(modifier):nonKeyModifiers.push(modifier):(keyModifiers.push(modifier),nonKeyModifiers.push(modifier)):isNonKeyModifier(modifier)?nonKeyModifiers.push(modifier):keyModifiers.push(modifier)}return{keyModifiers:keyModifiers,nonKeyModifiers:nonKeyModifiers,eventOptionModifiers:eventOptionModifiers}},transformClick=(key,event)=>{const isStaticClick=isStaticExp(key)&&"onclick"===key.content.toLowerCase();return isStaticClick?createSimpleExpression(event,!0):4!==key.type?createCompoundExpression(["(",key,`) === "onClick" ? "${event}" : (`,key,")"]):key},transformOn$1=(dir,node,context)=>transformOn(dir,node,context,baseResult=>{const{modifiers:modifiers}=dir;if(!modifiers.length)return baseResult;let{key:key,value:handlerExp}=baseResult.props[0];const{keyModifiers:keyModifiers,nonKeyModifiers:nonKeyModifiers,eventOptionModifiers:eventOptionModifiers}=resolveModifiers(key,modifiers);if(nonKeyModifiers.includes("right")&&(key=transformClick(key,"onContextmenu")),nonKeyModifiers.includes("middle")&&(key=transformClick(key,"onMouseup")),nonKeyModifiers.length&&(handlerExp=createCallExpression(context.helper(V_ON_WITH_MODIFIERS),[handlerExp,JSON.stringify(nonKeyModifiers)])),!keyModifiers.length||isStaticExp(key)&&!isKeyboardEvent(key.content)||(handlerExp=createCallExpression(context.helper(V_ON_WITH_KEYS),[handlerExp,JSON.stringify(keyModifiers)])),eventOptionModifiers.length){const modifierPostfix=eventOptionModifiers.map(capitalize).join("");key=isStaticExp(key)?createSimpleExpression(`${key.content}${modifierPostfix}`,!0):createCompoundExpression(["(",key,`) + "${modifierPostfix}"`])}return{props:[createObjectProperty(key,handlerExp)]}}),transformShow=(dir,node,context)=>{const{exp:exp,loc:loc}=dir;return exp||context.onError(createDOMCompilerError(57,loc)),{props:[],needRuntime:context.helper(V_SHOW)}},warnTransitionChildren=(node,context)=>{if(1===node.type&&1===node.tagType){const component=context.isBuiltInComponent(node.tag);if(component===TRANSITION$1)return()=>{node.children.length&&hasMultipleChildren(node)&&context.onError(createDOMCompilerError(58,{start:node.children[0].loc.start,end:node.children[node.children.length-1].loc.end,source:""}))}}};function hasMultipleChildren(node){const children=node.children=node.children.filter(c=>3!==c.type),child=children[0];return 1!==children.length||11===child.type||9===child.type&&child.branches.some(hasMultipleChildren)}const ignoreSideEffectTags=(node,context)=>{1!==node.type||0!==node.tagType||"script"!==node.tag&&"style"!==node.tag||(context.onError(createDOMCompilerError(59,node.loc)),context.removeNode())},DOMNodeTransforms=[transformStyle,warnTransitionChildren],DOMDirectiveTransforms={cloak:noopDirectiveTransform,html:transformVHtml,text:transformVText,model:transformModel$1,on:transformOn$1,show:transformShow};function compile$1(template,options={}){return baseCompile(template,extend({},parserOptions,options,{nodeTransforms:[ignoreSideEffectTags,...DOMNodeTransforms,...options.nodeTransforms||[]],directiveTransforms:extend({},DOMDirectiveTransforms,options.directiveTransforms||{}),transformHoist:null}))}initDev();const compileCache=Object.create(null);function compileToFunction(template,options){if(!isString(template)){if(!template.nodeType)return warn("invalid template option: ",template),NOOP;template=template.innerHTML}const key=template,cached=compileCache[key];if(cached)return cached;if("#"===template[0]){const el=document.querySelector(template);el||warn(`Template element not found or is empty: ${template}`),template=el?el.innerHTML:""}const{code:code}=compile$1(template,extend({hoistStatic:!0,onError(err){{const message=`Template compilation error: ${err.message}`,codeFrame=err.loc&&generateCodeFrame(template,err.loc.start.offset,err.loc.end.offset);warn(codeFrame?`${message}\n${codeFrame}`:message)}}},options)),render=new Function(code)();return render._rc=!0,compileCache[key]=render}return registerRuntimeCompiler(compileToFunction),exports.BaseTransition=BaseTransition,exports.Comment=Comment,exports.Fragment=Fragment,exports.KeepAlive=KeepAlive,exports.Static=Static,exports.Suspense=Suspense,exports.Teleport=Teleport,exports.Text=Text,exports.Transition=Transition,exports.TransitionGroup=TransitionGroup,exports.callWithAsyncErrorHandling=callWithAsyncErrorHandling,exports.callWithErrorHandling=callWithErrorHandling,exports.camelize=camelize,exports.capitalize=capitalize,exports.cloneVNode=cloneVNode,exports.compile=compileToFunction,exports.computed=computed$1,exports.createApp=createApp,exports.createBlock=createBlock,exports.createCommentVNode=createCommentVNode,exports.createHydrationRenderer=createHydrationRenderer,exports.createRenderer=createRenderer,exports.createSSRApp=createSSRApp,exports.createSlots=createSlots,exports.createStaticVNode=createStaticVNode,exports.createTextVNode=createTextVNode,exports.createVNode=createVNode,exports.customRef=customRef,exports.defineAsyncComponent=defineAsyncComponent,exports.defineComponent=defineComponent,exports.getCurrentInstance=getCurrentInstance,exports.getTransitionRawChildren=getTransitionRawChildren,exports.h=h,exports.handleError=handleError,exports.hydrate=hydrate,exports.inject=inject,exports.isProxy=isProxy,exports.isReactive=isReactive,exports.isReadonly=isReadonly,exports.isRef=isRef,exports.isVNode=isVNode,exports.markRaw=markRaw,exports.mergeProps=mergeProps,exports.nextTick=nextTick,exports.onActivated=onActivated,exports.onBeforeMount=onBeforeMount,exports.onBeforeUnmount=onBeforeUnmount,exports.onBeforeUpdate=onBeforeUpdate,exports.onDeactivated=onDeactivated,exports.onErrorCaptured=onErrorCaptured,exports.onMounted=onMounted,exports.onRenderTracked=onRenderTracked,exports.onRenderTriggered=onRenderTriggered,exports.onUnmounted=onUnmounted,exports.onUpdated=onUpdated,exports.openBlock=openBlock,exports.popScopeId=popScopeId,exports.provide=provide,exports.proxyRefs=proxyRefs,exports.pushScopeId=pushScopeId,exports.queuePostFlushCb=queuePostFlushCb,exports.reactive=reactive,exports.readonly=readonly,exports.ref=ref,exports.registerRuntimeCompiler=registerRuntimeCompiler,exports.render=render,exports.renderList=renderList,exports.renderSlot=renderSlot,exports.resolveComponent=resolveComponent,exports.resolveDirective=resolveDirective,exports.resolveDynamicComponent=resolveDynamicComponent,exports.resolveTransitionHooks=resolveTransitionHooks,exports.setBlockTracking=setBlockTracking,exports.setDevtoolsHook=setDevtoolsHook,exports.setTransitionHooks=setTransitionHooks,exports.shallowReactive=shallowReactive,exports.shallowReadonly=shallowReadonly,exports.shallowRef=shallowRef,exports.ssrContextKey=ssrContextKey,exports.ssrUtils=null,exports.toDisplayString=toDisplayString,exports.toHandlers=toHandlers,exports.toRaw=toRaw,exports.toRef=toRef,exports.toRefs=toRefs,exports.transformVNodeArgs=transformVNodeArgs,exports.triggerRef=triggerRef,exports.unref=unref,exports.useCssModule=useCssModule,exports.useCssVars=useCssVars,exports.useSSRContext=useSSRContext,exports.useTransitionState=useTransitionState,exports.vModelCheckbox=vModelCheckbox,exports.vModelDynamic=vModelDynamic,exports.vModelRadio=vModelRadio,exports.vModelSelect=vModelSelect,exports.vModelText=vModelText,exports.vShow=vShow,exports.version=version,exports.warn=warn,exports.watch=watch,exports.watchEffect=watchEffect,exports.withCtx=withCtx,exports.withDirectives=withDirectives,exports.withKeys=withKeys,exports.withModifiers=withModifiers,exports.withScopeId=withScopeId,exports}({});